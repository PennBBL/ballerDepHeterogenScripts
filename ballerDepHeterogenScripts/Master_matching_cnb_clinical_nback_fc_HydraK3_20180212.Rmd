---
title: "Master file"
author: "Erica Baller"
date: "2/27/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width = 9)
library(visreg)
library(mgcv)
library(tableone)
library(dplyr)
library(plm)
library(MatchIt)
library(tidyr)
library(ggplot2)
library(reshape)
library(emmeans)
library(MASS)
require(cowplot)
require(stringr)
require(rasterVis)
require(lattice)
theme_update(plot.title = element_text(hjust = 0.5))
source("~/BBL/from_chead/ballerDepHeterogen/ballerDepHeterogenScripts/Hydra_functions.R")
```

## R Markdown

This is the master document containing the final analyses for the project: 
Semisupervised Machine Learning Reveals Three Subtypes of Cognitive Function in Depressed Youths

Steps:
1) Sample construction
-We started with the CNB sample (9498 youths aged 8-22)
-Youths were excluded if they did not have age, sex, gender or maternal education documented
-Youths were also excluded if they had missing data for any of the 26 cognitive measures (12 accuracy, 14 speed)
-712 depressed youths and 2310 remained

2) Matching
- Using the R package Matchit, depressed youths were age and sex matched with typically developing youth
- Match was performed in 2 steps to allow us to enrich our TD group with children who had imaging
- Step 1: Depressed youth with imaging(200) were matched with youths with imaging. Results: 187 depressed and 187 TDs matched 
- Step 2: People who were matched in Step 1 were removed from the original groups (unmatched: Depressed 525, TD 2123)
- Step 3: Subjects from TD group that do not have imaging were removed
- Step 4: Match was rerun for depressed without imaging with TDs WITH imaging
- Step 5: Groups were combined and demographics were checked to ensure that the groups were still matched
- Of note: Matchit does depend on random seeding, so each iteration generates VERY SLIGHT differences between groups

3) HYDRA
- Final matched groups were output to csv and sent to HYDRA for subtyping
- Use groups generated from 6/11/2018 run of matchit

4)Cognitive analysis
- Results from HYDRA revealed highest ARI (0.39) for 3 subtype solution
- CNB Factor Summary Scores (Accuracy, Speed, Efficiency) were evaluated
- Results:
   - Subtype 1: Cognition Preserved 
   - Subtype 2: Cognition Impaired
   - Subtype 3: Impulsive

5) Clinical bifactor analysis
- Bifactor scores were calculated (excluding measures that were used to classify depression in initial sample construction)
- Subtypes were evaluated on 5 bifactor scores (anxious-misery, psychosis, externalizing, fear, and overall psychopathology)
- Results:
  -All subtypes had higher psychopathology than TDs (P(FDR)< 0.05)
  -Subtypes 1 and 3 were indistinguishable on clinical factor scores (P(FDR) = NS)
  -Subtype 2 had higher fear scores than Subtypes 1 and 3 (P(FDR)<0.0001)

6) Anxious-misery analysis
- Anxious misery factor scores were calculated (Provided by Toni and Tyler, used in Toni's previous paper)
- Subtypes were evaluated on state and trait factors to verify cognitive differences weren't due to state difference
- Results:
  - All subtypes had significantly higher state (P(FDR) = 0.001) and trait (P(FDR)<0.001) anxiety
    - State Pairwise: 
      -Subtype 1 vs TD (P=0.012)
      -Subtype 2 vs TD (P=0.004)
      -Subtype 3 vs TD (P=0.063, NS)
    - Trait Pairwise: All Subtypes vs TD (P<0.001)
  - Subtypes 1-3 did NOT differ on EITHER state or trait anxiety (P=NS)

7) Nback
-Using 27 functionally defined regions of interest from Satterthwaite et al, 2013, percent signal change between 2bk and 0bk was evaluated by cluster
- Results:
  - 8 areas showed significant differences (P(FDR)<0.05) by subtype including 
    -right crus I
    -right crus II
    -right precuneus
    -left precuneus
    -left parietal
    -dorsal anterior cingulate
    -left dorsal frontal/mfg
    -left dorsolateral prefrontal cortex 
    
8) Functional Connectivity    
-Functional connectivity between areas that were significantly different by subtype in the N-back activation and analysis were evaluated
-Network and nodal strength between groups were assessed
-Results:
  -Network Strength differed by subtype (p=0.043)
  -Nodal strength differed by subtype for the following areas (P(unc) < 0.05)
    -right crus I (P= 0.03)		
    -right crus II (P= 0.03)


```{r sample_construction}
set.seed(1)

#read in csvs
demographics <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv
cnb_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_cnb_zscores_fr_20170202.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_cnb_zscores_fr_20170202.csv
health <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_health_20170405.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_health_20170405.csv
psych_summary <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv
imaging_summary <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/neuroimaging/t1struct/n1601_t1QaData_20170306.csv")

#remove people with NA for race, age, or sex.  START WITH N = 9498
demographics_noNA_race <- demographics[!is.na(demographics$race),] #everyone has a race, N = 9498
demographics_noNA_race_age <- demographics_noNA_race[!is.na(demographics_noNA_race$ageAtClinicalAssess1),] # 86 people do not have age at clinical assessment.  N = 9412
demographics_noNA_race_age_sex <- demographics_noNA_race_age[!is.na(demographics_noNA_race_age$sex),] #everyone has a sex, N = 9412
demographics_noNA_race_age_andCNBage_sex <- demographics_noNA_race_age_sex[!is.na(demographics_noNA_race_age_sex$ageAtCnb1),] #6 people do not have ageAtCnb1, N = 9406

#remove people with NA for depression or total psych score, START WITH N = 9498
psych_summary_no_NA_dep <- psych_summary[!is.na(psych_summary$smry_dep),] #take out those with NA for depression, 87 people N = 9411
psych_summary_no_NA_dep_and_smry_psych_overall <- psych_summary_no_NA_dep[!is.na(psych_summary_no_NA_dep$smry_psych_overall_rtg),] #take out those with NA for overall psych rtg, no additional people lost, N = 9411

#only include good imaging scans, n = 1540
imaging_include <- subset.data.frame(imaging_summary, (t1Exclude == 0))

#merge the csvs
#merge demographics and cnb #this is if we want to include people without full demographic data
dem_cnb <- merge(demographics_noNA_race_age_andCNBage_sex, cnb_scores, by = "bblid") #merge demographics and cnb, N = 9406
psych_health <- merge(psych_summary_no_NA_dep_and_smry_psych_overall, health, by = "bblid") #merge psych and health, N = 9411
dem_cnb_psych_health_merged <- merge(dem_cnb, psych_health, by = "bblid") #merge all 4 csvs, lost 1 person [134716] (had demographics, but no psych ratings): N = 9405
dem_merged_with_imaging_as_well <- merge(dem_cnb_psych_health_merged, imaging_include, by = "bblid")

#make subsets, 
subset_just_dep_and_no_medicalratingExclude <- subset.data.frame(dem_cnb_psych_health_merged, ((medicalratingExclude == 0) & (smry_dep == 4))) #subset people who were not medically excluded and who are depressed, N = 776
subset_no_psych_no_medicalratingExclude <- subset.data.frame(dem_cnb_psych_health_merged, ((medicalratingExclude == 0) & (smry_psych_overall_rtg < 4))) #subset people who are psychiatrically healthy, N = 2508
subset_nondep_imaging <-  subset.data.frame(dem_merged_with_imaging_as_well, ((medicalratingExclude == 0) & (smry_dep < 4))) #n = 1266
subset_dep_imaging <-  subset.data.frame(dem_merged_with_imaging_as_well, ((medicalratingExclude == 0) & (smry_dep == 4)))#n = 200

#subsets with depressed AND non depressed, without OR with imaging :  without imaging n = 3284, with imaging, n = 703
subset_dep_or_no_psych_and_no_medicalratingExclude <- subset.data.frame(dem_cnb_psych_health_merged, (medicalratingExclude == 0) & ((smry_dep == 4) | (smry_psych_overall_rtg <4))) #subset including both depressed and healthies, N = 3284
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging <- subset.data.frame(dem_merged_with_imaging_as_well, (medicalratingExclude == 0) & ((smry_dep == 4) | (smry_psych_overall_rtg <4))) #subset including both depressed and healthies, N = 703

#would binarize depression smry score to -1 (less than 4, not depressed) and 1 (score 4 , depressed)
dep_binarized <- ifelse(subset_dep_or_no_psych_and_no_medicalratingExclude$smry_dep == 4, 1, -1)
dep_binarized_with_imaging <- ifelse(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging$smry_dep == 4, 1, -1)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- cbind(subset_dep_or_no_psych_and_no_medicalratingExclude, dep_binarized) #N = 3284
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED <- cbind(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging, dep_binarized_with_imaging) #N = 703

#make depression and gender into factor scores 
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized)
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$dep_binarized <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$dep_binarized)

subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex)
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$sex <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$sex)

#divide ageAtCNB by 12 for age 
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageAtCnb1/12
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$age_in_years <- subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$ageAtCnb1/12

#age demeaned and squared
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageSq <- as.numeric(I(scale(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years, scale = FALSE, center = TRUE)^2))
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$ageSq <- as.numeric(I(scale(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$age_in_years, scale = FALSE, center = TRUE)^2))

#race binarized for plotting purposes, caucasian 1, non-caucasion 0
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race_binarized <- ifelse(as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race) == 1, 1, 0)
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$race_binarized <- ifelse(as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED$race) == 1, 1, 0)

#remove people with NA in their cognitive measures, we lose 252 for whole group, and 57 with imaging at this stage, n for NO imaging = 3022, n for WITH IMAGING = 646(dep = 187, non-dep = 459)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[complete.cases(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[14:39]),] #n=3022
subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED <- subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED[complete.cases(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED[14:39]),] # n = 646

```

```{r matching}

#Steps for this section
####1. Match depress w/ imaging to controls w/imaging
####2. Removed these from full group
####3. Match remaining depressed without imaging to controls who weren't previously matched
####4. Combine depressed w/imaging to depressed w/out imaging and controls w/imaging to controls w/out imaging
####5. Check distribution of these groups

#########Let's start by matching only depressed people with imaging to controls with imaging###
#match with matchit depressed n =187
#### matching on age_and_sex: dep: m/f (70/117), non dep:m/f (70/117)

data.unmatched = subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED[complete.cases(subset_dep_or_no_psych_and_no_medicalratingExclude_with_imaging_DEPBINARIZED[14:39]),]
data.unmatched$unmatchedRows =rownames(data.unmatched)
dataset = data.unmatched

# Some preprocessing
dataset = dplyr::select(dataset, sex, age_in_years, ageSq, medu1, race_binarized, dep_binarized, unmatchedRows)

#dataset = dplyr::filter(dataset, !is.na(group))
# Dep: 1, Health = 0 
dataset$dep_binarized = 1*(dataset$dep_binarized==1) 

#"male": 1, "female": 0
dataset$sex = 1*(dataset$sex==1)

# Remove subjects with NA for maternal edu, new N = 3256, males = 1539, females 1717
dataset <- dataset[!is.na(dataset$medu1),]

# Plot prematch
plot(dataset$age_in_years,jitter(dataset$medu1, factor=3), pch=c(15, 7, 18, 9), col=c(1,2,3,4), ylab="Maternal Edu", xlab="Age")
legend("bottomright",c("Non-white, non-depressed", "Non-white, depressed", "White, non-depressed", "White, depressed"),pch=c(15, 7, 18, 9), col=c(1,2,3,4))

#post_match
m_age_and_sex.out <-matchit(dep_binarized ~ age_in_years + sex, data=dataset, method="nearest", distance="mahalanobis")
plot(m_age_and_sex.out)
m_age_and_sex.data <- match.data(m_age_and_sex.out)
plot(m_age_and_sex.data$age_in_years,jitter(m_age_and_sex.data$medu1, factor=3), pch=c(15, 7, 18, 9), col=c(1,2,3,4), ylab="Maternal Edu", xlab="Age and sex matched")
legend("bottomright",c("Non-white, non-depressed", "Non-white, depressed", "White, non-depressed", "White, depressed"),pch=c(15, 7, 18, 9), col=c(1,2,3,4))


# Make the final matched data set
data_age_and_sex.matched = data.unmatched[data.unmatched$unmatchedRows%in%m_age_and_sex.data$unmatchedRows,]
data_age_and_sex.matched$unmatchedRows = NULL

##############
#Demo Tablets#
##############
#Make table 1 (demographics) for matched data
#subset demographics
listVars <- c("Race_binarized", "Sex", "Maternal Ed", "Age", "Depression") #Race 1 = caucasian, Maternal Ed = years, age = years, dep 1 = dep, 0 = non_dep
matched_versions <- c("data_age_and_sex")

for(vers in matched_versions) {
  demo_string_to_eval <- paste("data.frame(", vers , ".matched$race_binarized, ", vers, ".matched$sex, ", vers, ".matched$medu1, ", vers, ".matched$age_in_years, ", vers, ".matched$dep_binarized)", sep ="")
  demo_data.matched <- eval(parse(text=as.name(demo_string_to_eval)))
  names(demo_data.matched) <- c(listVars)
  
  #Change categorical values to have names
  demo_data.matched$Depression <- ifelse(demo_data.matched$Depression == 1, "Depressed", "Non-depressed")
  demo_data.matched$Race <- ifelse(demo_data.matched$Race == 1, "Caucasian", "Non-caucasian")
  demo_data.matched$Sex <- ifelse(demo_data.matched$Sex == 1, "Male", "Female")
  
  #make variable list
  table_titles <- c("Non-depressed", "Depressed", "P-value")
  
  #Define Categorical Variables
  cat_variables <- c("Race", "Depression", "Sex")
  
  #create demographics table
  demo_data.matched_table <- CreateTableOne(vars = listVars, data = demo_data.matched, factorVars = cat_variables, strata = c("Depression"))
  print(paste("Version matching on ", vers))
  print(demo_data.matched_table, showAllLevels = TRUE)
  
  #rename the data***.matched to have an imaging end to it, so we can use it to combine
  rename_string_to_eval <- paste(vers, ".matched_imaging <- ", vers, ".matched", sep = "")
  eval(parse(text = as.name(rename_string_to_eval)))
}

### Match non-imaging depressed 

people_from_imaging_match_age_and_sex <- data_age_and_sex.matched$bblid
subset_people_who_were_not_included_in_imaging_match_age_and_sex <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[!(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$bblid %in% c(people_from_imaging_match_age_and_sex)),]

data.unmatched = subset_people_who_were_not_included_in_imaging_match_age_and_sex[complete.cases(subset_people_who_were_not_included_in_imaging_match_age_and_sex[14:39]),]
data.unmatched$unmatchedRows =rownames(data.unmatched)
dataset = data.unmatched

# Some preprocessing
#dataset = dplyr::select(dataset, sex, age_in_years, ageSq, medu1, race, dep_binarized, unmatchedRows)
dataset = dplyr::select(dataset, sex, age_in_years, ageSq, medu1, race_binarized, dep_binarized, unmatchedRows)

#dataset = dplyr::filter(dataset, !is.na(group))
# Dep: 1, Health = 0 
dataset$dep_binarized = 1*(dataset$dep_binarized==1) 

#"male": 1, "female": 0
dataset$sex = 1*(dataset$sex==1)

# Remove subjects with NA for maternal edu, new N = 3256, males = 1539, females 1717
dataset <- dataset[!is.na(dataset$medu1),]

# Plot prematch
plot(dataset$age_in_years,jitter(dataset$medu1, factor=3), pch=c(15, 7, 18, 9), col=c(1,2,3,4), ylab="Maternal Edu", xlab="Age")

legend("bottomright",c("Non-white, non-depressed", "Non-white, depressed", "White, non-depressed", "White, depressed"),pch=c(15, 7, 18, 9), col=c(1,2,3,4))

#Will do a variety of matchings, using all variables combined, then age, sex, medu and race separately
m_age_and_sex.out <-matchit(dep_binarized ~ age_in_years + sex, data=dataset, method="nearest", distance="mahalanobis")
plot(m_age_and_sex.out)
m_age_and_sex.data <- match.data(m_age_and_sex.out)

# Re-plot
plot(m_age_and_sex.data$age_in_years,jitter(m_age_and_sex.data$medu1, factor=3), pch=c(15, 7, 18, 9), col=c(1,2,3,4), ylab="Maternal Edu", xlab="Age age and sex matched")
legend("bottomright",c("Non-white, non-depressed", "Non-white, depressed", "White, non-depressed", "White, depressed"),pch=c(15, 7, 18, 9), col=c(1,2,3,4))

data_age_and_sex.matched = data.unmatched[data.unmatched$unmatchedRows%in%m_age_and_sex.data$unmatchedRows,]
data_age_and_sex.matched$unmatchedRows = NULL

### New Demographics
listVars <- c("Race_binarized", "Sex", "Maternal Ed", "Age", "Depression") #Race 1 = caucasian, Maternal Ed = years, age = years, dep 1 = dep, 0 = non_dep
matched_versions <- c("data_age_and_sex")

for(vers in matched_versions) {
  demo_string_to_eval <- paste("data.frame(", vers , ".matched$race_binarized, ", vers, ".matched$sex, ", vers, ".matched$medu1, ", vers, ".matched$age_in_years, ", vers, ".matched$dep_binarized)", sep ="")
  demo_data.matched <- eval(parse(text=as.name(demo_string_to_eval)))
  names(demo_data.matched) <- c(listVars)
  
  #Change categorical values to have names
  demo_data.matched$Depression <- ifelse(demo_data.matched$Depression == 1, "Depressed", "Non-depressed")
  demo_data.matched$Race <- ifelse(demo_data.matched$Race == 1, "Caucasian", "Non-caucasian")
  demo_data.matched$Sex <- ifelse(demo_data.matched$Sex == 1, "Male", "Female")
  
  #make variable list
  table_titles <- c("Non-depressed", "Depressed", "P-value")
  
  #Define Categorical Variables
  cat_variables <- c("Race", "Depression", "Sex")
  
  #create demographics table
  demo_data.matched_table <- CreateTableOne(vars = listVars, data = demo_data.matched, factorVars = cat_variables, strata = c("Depression"))
  print(paste("Version matching on ", vers))
  print(demo_data.matched_table, showAllLevels = TRUE)
  
  #rename the data***.matched to have a non-imaging end to it, so we can use it to combine
  rename_string_to_eval <- paste(vers, ".matched_non_imaging <- ", vers, ".matched", sep = "")
  eval(parse(text = as.name(rename_string_to_eval)))
  
}

###############Combine imaging matched and imaging non-matched groups ####################

#first remove imaging info from the imaging group
#Gets you a group of 1424 , just like original.... YAY!
data_age_and_sex.matched_imaging_without_imaging_data_in_data_frame <- data_age_and_sex.matched_imaging[,-c(77:89)]
imaging_plus_non_imaging_matched_groups_data_age_and_sex <- rbind(data_age_and_sex.matched_imaging_without_imaging_data_in_data_frame, data_age_and_sex.matched_non_imaging)

####Demographics check#####
#subset demographics
listVars <- c("Race_binarized", "Sex", "Maternal Ed", "Age", "Depression") #Race 1 = caucasian, Maternal Ed = years, age = years, dep 1 = dep, 0 = non_dep
matched_versions <- c("data_age_and_sex")
short <- "imaging_plus_non_imaging_matched_groups_"

for(vers in matched_versions) {
  demo_string_to_eval <- paste("data.frame(", short, vers , "$race_binarized, ", short, vers, "$sex, ", short, vers, "$medu1, ", short, vers, "$age_in_years, ", short, vers, "$dep_binarized)", sep ="")
  demo_data.matched <- eval(parse(text=as.name(demo_string_to_eval)))
  names(demo_data.matched) <- c(listVars)
  
  #Change categorical values to have names
  demo_data.matched$Depression <- ifelse(demo_data.matched$Depression == 1, "Depressed", "Non-depressed")
  demo_data.matched$Race <- ifelse(demo_data.matched$Race == 1, "Caucasian", "Non-caucasian")
  demo_data.matched$Sex <- ifelse(demo_data.matched$Sex == 1, "Male", "Female")
  
  #make variable list
  table_titles <- c("Non-depressed", "Depressed", "P-value")
  
  #Define Categorical Variables
  cat_variables <- c("Race", "Depression", "Sex")
  
  #create demographics table
  demo_data.matched_table <- CreateTableOne(vars = listVars, data = demo_data.matched, factorVars = cat_variables, strata = c("Depression"))
  print(paste("Version matching on ", vers))
  print(demo_data.matched_table, showAllLevels = TRUE)
  
  #rename the data***.matched to have a non-imaging end to it, so we can use it to combine
  rename_string_to_eval <- paste(vers, ".matched_non_imaging <- ", vers, ".matched", sep = "")
  eval(parse(text = as.name(rename_string_to_eval)))
  
}

#### Make csv ###
short <- "imaging_plus_non_imaging_matched_groups_"
matched_versions <- c("data_age_and_sex")
string_to_eval_cov <- paste("data.frame(", short, "data_age_and_sex[1], ", short, "data_age_and_sex[78], ", short, "data_age_and_sex[2])", sep = "")
subset_bblidAndCog_cov <- eval(parse(text = as.name(string_to_eval_cov)))
write.csv(subset_bblidAndCog_cov, file="/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/hydra_matched/matched_imaging_plus_non_imaging/cov_age_and_sex_replication_20190212.csv", row.names = FALSE, quote = FALSE)
```

```{r CNB}
# All of these results use groups generated by matching script 6/11/2018 #
num_clusters <- 3
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)

#read in csvs
demographics <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv
cnb_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_cnb_zscores_fr_20170202.csv", header = TRUE, sep = ",") 
health <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_health_20170405.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_health_20170405.csv
psych_summary <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv
cnb_factor_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_cnb_factor_scores_fr_20170202.csv", header = TRUE, sep = ",")
extended_names <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/dictionaries/cnb_scores_and_names.csv", header = TRUE) #reads a 2 column table with mappings of cnb scores to actual names

#read in Hydra cluster data -> AG (all_gender), M(males), F(females) 
#hydra_AG_matched_clusters <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/hydra_output_from_cbica/hydra_matched/matched_imaging_plus_non_imaging/CogData_matched_age_and_sex_n1424_matched_imaging_plus_non_imaging_HydraSubtypes.csv", header = TRUE, sep = ",")

hydra_AG_matched_clusters <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/hydra_output_from_cbica/hydra_matched/20181121_OLD_HYDRA_with_new_script_from_toni/CogData_age_and_sex_n1424_matched_imaging_plus_non_imaging_replication_20181121_HydraSubtypes.csv", header = TRUE, sep = ",")

hydra_aris <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/hydra_output_from_cbica/hydra_matched/20181121_OLD_HYDRA_with_new_script_from_toni/CogData_age_and_sex_n1424_matched_imaging_plus_non_imaging_replication_20181121_ARI.csv", header = FALSE, sep = ",")

#Coerce hydra values into factor format
hydra_names <- names(hydra_AG_matched_clusters[2:11])
hydra_AG_matched_clusters[hydra_names] <- lapply(hydra_AG_matched_clusters[hydra_names], factor)


############
#prepping and merging big CNB and demographics stuff
############

#remove people with NA for race, age, or sex.  START WITH N = 9498
demographics_noNA_race <- demographics[!is.na(demographics$race),] #everyone has a race, N = 9498
demographics_noNA_race_age <- demographics_noNA_race[!is.na(demographics_noNA_race$ageAtClinicalAssess1),] # 86 people do not have age at clinical assessment.  N = 9412
demographics_noNA_race_age_sex <- demographics_noNA_race_age[!is.na(demographics_noNA_race_age$sex),] #everyone has a sex, N = 9412
demographics_noNA_race_age_andCNBage_sex <- demographics_noNA_race_age_sex[!is.na(demographics_noNA_race_age_sex$ageAtCnb1),] #6 people do not have ageAtCnb1, N = 9406

#remove people with NA for depression or total psych score, START WITH N = 9498
psych_summary_no_NA_dep <- psych_summary[!is.na(psych_summary$smry_dep),] #take out those with NA for depression, 87 people N = 9411
psych_summary_no_NA_dep_and_smry_psych_overall <- psych_summary_no_NA_dep[!is.na(psych_summary_no_NA_dep$smry_psych_overall_rtg),] #take out those with NA for overall psych rtg, no additional people lost, N = 9411

#merge demographics and cnb #this is if we want to include people without full demographic data
dem_cnb <- merge(demographics_noNA_race_age_andCNBage_sex, cnb_scores, by = "bblid") #merge demographics and cnb, N = 9406
psych_health <- merge(psych_summary_no_NA_dep_and_smry_psych_overall, health, by = "bblid") #merge psych and health, N = 9411
dem_cnb_psych_health_merged <- merge (dem_cnb, psych_health, by = "bblid") #merge all 4 csvs, lost 1 person [134716] (had demographics, but no psych ratings): N = 9405
dem_cnb_psych_health_factor_scores_merged <- merge(dem_cnb_psych_health_merged, cnb_factor_scores, by = "bblid")

#make subsets
subset_just_dep_and_no_medicalratingExclude <- subset.data.frame(dem_cnb_psych_health_factor_scores_merged, (medicalratingExclude == 0) & (smry_dep == 4), select = "bblid") #subset people who were not medically excluded and who are depressed, N = 776
subset_no_psych_no_medicalratingExclude <- subset.data.frame(dem_cnb_psych_health_factor_scores_merged, (medicalratingExclude == 0) & (smry_psych_overall_rtg < 4), select = "bblid") #subset people who are psychiatrically healthy, N = 2508
subset_dep_or_no_psych_and_no_medicalratingExclude <- subset.data.frame(dem_cnb_psych_health_factor_scores_merged, (medicalratingExclude == 0) & ((smry_dep == 4) | (smry_psych_overall_rtg <4))) #subset including both depressed and healthies, good for regressions, N = 3284

#would binarize depression smry score to -1 (less than 4, not depressed) and 1 (score 4 , depressed)
dep_binarized <- ifelse(subset_dep_or_no_psych_and_no_medicalratingExclude$smry_dep == 4, 1, -1)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- cbind(subset_dep_or_no_psych_and_no_medicalratingExclude, dep_binarized) #N = 3284

#make depression and gender into factor scores
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex)

#divide ageAtCNB by 12 for age
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageAtCnb1/12

#race binarized for plotting purposes, caucasian 1, non-caucasion 0
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race_binarized <- ifelse(as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race) == 1, 1, 0)

#add age squared mean-centered term for use in LM
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageSq <- as.numeric(I(scale(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years, scale = FALSE, center = TRUE)^2))

#remove people with NA in their cognitive measures
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[complete.cases(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[14:39]),]

################################################
### Merge clustering data with subsetted data ##
################################################

#AG (all gender), M (males), F (females) 
#AG Matched - n 1424

subset_with_clusters_AG_matched <- merge(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED, hydra_AG_matched_clusters, by = "bblid")
clusters <- names(subset_with_clusters_AG_matched[grep ("Hydra", names(subset_with_clusters_AG_matched))])
summary_factor_scores <- names(subset_with_clusters_AG_matched[grep ("NAR_Overall", names(subset_with_clusters_AG_matched))])

#######Matched group all clusters ##############

make_demographics_table(data_frame = subset_with_clusters_AG_matched, hydra_cluster = num_clusters)

#### Graphing ###
###########################
###Graph ARI values #######
###########################

#preprocessing - this will use TONI's beautiful coding 
seq_10 <- seq(1:10)
hydra_aris_for_plot <- cbind(seq_10, hydra_aris)
names(hydra_aris_for_plot) <- c("cluster", "ARI")

ggplot(data=hydra_aris_for_plot, aes(x=cluster, y=ARI, group=1)) +
  geom_line(color="black", size=1.5) +
  theme_classic(base_size = 24) +
  ggtitle("Adjusted Rand Index") + 
  theme(legend.position="none", 
        plot.title = element_text(hjust = 0.5), 
        axis.ticks.length = unit(5, "pt"),
        axis.ticks = element_line(size = 1.5),
        axis.line= element_line(size = 1.5),
        axis.text = element_text(face="bold")) +
  scale_y_continuous(breaks=c(0,.10,.20,.30,.40,.50,.60,.70)) +
  expand_limits(y=.5) +
  scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10)) +
  labs(x = "Number of Subtypes") +
  geom_segment(aes(x = 3, y = 0, xend = 3, yend = .39), linetype="dashed", color = "red", size=1.5) +
  annotate(geom="text", x=3, y=.42, label="0.39", color="red", size=9) 
 
#ARIs 1-6
seq_6 <- seq(1:6)
hydra_aris_for_plot <- cbind(seq_6, data.frame(hydra_aris[1:6,1]))
names(hydra_aris_for_plot) <- c("cluster", "ARI")

ggplot(data=hydra_aris_for_plot, aes(x=cluster, y=ARI, group=1)) +
  geom_line(color="black", size=1.5) +
  theme_classic(base_size = 24) +
  ggtitle("Adjusted Rand Index") + 
  theme(legend.position="none", 
        plot.title = element_text(hjust = 0.5), 
        axis.ticks.length = unit(5, "pt"),
        axis.ticks = element_line(size = 1.5),
        axis.line= element_line(size = 1.5),
        axis.text = element_text(face="bold")) +
  scale_y_continuous(breaks=c(0,.10,.20,.30,.40,.50,.60)) +
  expand_limits(y=.5) +
  scale_x_continuous(breaks=c(1,2,3,4,5,6)) +
  labs(x = "Number of Subtypes") +
  geom_segment(aes(x = 3, y = 0, xend = 3, yend = .39), linetype="dashed", color = "red", size=1.5) +
  annotate(geom="text", x=3, y=.42, label="0.39", color="red", size=9) 
 

#######Chi-square for males/females and race########
##########By males, and by caucasians ##############

#Chi squared 
chisq_matched_sex <- chi_sq(data_frame = subset_with_clusters_AG_matched, "sex", num_clusters)
chisq_matched_race <- chi_sq(data_frame = subset_with_clusters_AG_matched, "race_binarized", num_clusters)

#get means/stds
total_people_Hydra <- total_people_per_cluster(data_frame = subset_with_clusters_AG_matched, hydra_cluster = num_clusters)

num_men_all_clusters <- total_people_per_cluster_by_group(data_frame = subset_with_clusters_AG_matched, variable = "sex", hydra_cluster = num_clusters, group_val = 1)
num_caucasian_all_clusters <- total_people_per_cluster_by_group(data_frame = subset_with_clusters_AG_matched, variable = "race_binarized", hydra_cluster = num_clusters, group_val = 1)

percent_men_all_clusters <- (num_men_all_clusters/total_people_Hydra) * 100
percent_caucasian_all_clusters <- (num_caucasian_all_clusters/total_people_Hydra)*100

p_values <- c("", chisq_matched_sex$p.value, "", chisq_matched_race$p.value)

dat_sex_race <- data.frame(cl = c(cluster_titles, "Significance"), 
                           num_males = c(num_men_all_clusters, "---"),
                           percent_males = round(c(percent_men_all_clusters, chisq_matched_sex$p.value), 2), 
                           num_caucasians = c(num_caucasian_all_clusters, "---"),
                           percent_caucasian = round(c(percent_caucasian_all_clusters, chisq_matched_race$p.value),2))
dat_sex_race_no_significance <-  data.frame(cl = cluster_titles, 
                                            num_males = (num_men_all_clusters),
                                            percent_males = percent_men_all_clusters, 
                                            num_caucasians = num_caucasian_all_clusters,
                                            percent_caucasian = percent_caucasian_all_clusters)                 
percentages <- data.frame(cl=cluster_titles, percent_males = percent_men_all_clusters, percent_caucasians = percent_caucasian_all_clusters)
percentages_for_plot <- melt(percentages, id.vars = "cl")
names(percentages_for_plot) <- c("cluster", "group", "percent")

#Set Titles for plots
title1 <- paste0("Hydra_k", num_clusters, " Percentages")

if(chisq_matched_sex$p.value < 0.05) {
  title2 <- paste0("Hydra_k", num_clusters, "% Male, p < 0.05")
} else {
  title2 <- paste0("Hydra_k", num_clusters, "% Male, p = ", round(chisq_matched_sex$p.value, 2))
}

if(chisq_matched_race$p.value < 0.05) {
  title3 <- paste0("Hydra_k", num_clusters, "% Caucasian, p < 0.05")
} else {
  title3 <- paste0("Hydra_k", num_clusters, "% Caucasian, p = ", round(chisq_matched_race$p.value, 2))
}

#plot
ggplot(data = percentages_for_plot, aes(x = group, y = percent, group = cluster)) + 
  geom_line(aes(color=cluster)) +
  geom_point(aes(color=cluster)) + 
  ggtitle(title1)

ggplot(dat_sex_race_no_significance, aes(x = cl, y = percent_males, fill=cl)) + geom_col() +
  scale_x_discrete(limits=cluster_titles) + ylim(0, 100) + xlab("Subtypes") + ylab("% Male") + 
  ggtitle(title2) + scale_fill_discrete(breaks=cluster_titles) +
  guides(fill=guide_legend(title=NULL))

ggplot(dat_sex_race_no_significance, aes(x = cl, y = percent_caucasian, fill=cl)) + geom_col() + 
  scale_x_discrete(limits=cluster_titles) + ylim(0, 100) + xlab("Subtypes") + ylab("% Caucasian") + 
  ggtitle(title3) + scale_fill_discrete(breaks=cluster_titles) + 
  guides(fill=guide_legend(title=NULL))

#############################
######### Bar Graphs ########
#############################

variable_name_string <- c("age", "medu") #this allows you to specify the actual titles, if different from the data frame titles
plot_list <- plot_continuous_variables(data_frame = subset_with_clusters_AG_matched, var1 = "age_in_years", var2 = "medu1", hydra_cluster = num_clusters, optional_variable_name_string = variable_name_string)
for(x in 1:length(plot_list)){
  print(plot_list[[x]])
}

#### Linear model ####
#################################
# Linear Model for each measure #
##### Results stored in list ####
#################################

#get CNB measure names
cnb_measure_names <- names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED)[grep("_z", names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED))] #get the names of all the columns with _z in the name

cnb_speed_names <- cnb_measure_names[grep(pattern = "s_z", x = cnb_measure_names)]
cnb_accuracy_names <- cnb_measure_names[grep(pattern = "s_z", x = cnb_measure_names, invert = TRUE)]

cluster_names <- colnames(hydra_AG_matched_clusters[,2:11])

cnb_measure_names_list <- names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED)[grep("_z", names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED))] #get the names of all the columns with _z in the name
cluster_names_list <- colnames(hydra_AG_matched_clusters[,2:11])


#lm ageSq and mean centered
cnb_score_cluster_stats_lm_agesq_AG_matched <- lapply(cnb_measure_names, function(x) 
{
  lm(substitute(i ~ Hydra_k3 + sex + age_in_years + ageSq , list(i = as.name(x))), data = subset_with_clusters_AG_matched)
})
names(cnb_score_cluster_stats_lm_agesq_AG_matched) <- cnb_measure_names

#lm Hydra K3 Anova
cnb_score_cluster_stats_anova_lm_agesq_AG_matched <- lapply(cnb_score_cluster_stats_lm_agesq_AG_matched, anova) 
names(cnb_score_cluster_stats_anova_lm_agesq_AG_matched) <- cnb_measure_names


###################################################
### Average Z-scores for accuracy and speed #######
###################################################
#Get stats of mean accuracy, processing speed and efficiency 
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
numeric_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups_list <- data.frame(cbind(c(cluster_titles), c(numeric_vector)))
names(groups_list) <- c("cl", "numeric")
all_mean_sd_sem <- data.frame(rep(groups_list$cl, length(summary_factor_scores)), rep(summary_factor_scores, each = length(numeric_vector)), rep(0, 1), rep(0, 1), rep(0,1))
names(all_mean_sd_sem) <- c("cl", "cnb", "mean", "sd", "sem")
for(cnb in summary_factor_scores){
  for(num in 1:length(numeric_vector)) {
    clst <- groups_list[num,1]
    meas <- groups_list[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sd_grp
    sem_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")))", sep="")
    sem_grp <- eval(parse(text=as.name(sem_for_eval)))
    all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sem_grp
  }
}
names(all_mean_sd_sem) <- c("cluster", "cnb", "mean", "sd", "sem")

#remove the NAR_Overall from everything
summary_scores_first_letter_cap <- c("Accuracy", "Speed", "Efficiency")
newNames<- rep(summary_scores_first_letter_cap, each = num_clusters + 1)
all_mean_sd_sem$newNames <- newNames

ggplot(data = all_mean_sd_sem, aes(x = factor(newNames, level = summary_scores_first_letter_cap), y = mean, group = cluster)) + ylab("Mean Z-score") + xlab("Summary Scores") + 
  ggtitle("CNB Summary Factor Scores") +
  geom_line(aes(color=cluster, size=.1), show.legend = F) +
  geom_point(aes(color=cluster)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(name = " ") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 30), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

#####################################
###### By CNB Measure ###############
#####################################
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
numeric_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups_list <- data.frame(cbind(c(cluster_titles), c(numeric_vector)))
names(groups_list) <- c("cl", "numeric")
all_mean_sd_sem <- data.frame(rep(groups_list$cl, length(cnb_measure_names)), rep(cnb_measure_names, each = length(numeric_vector)), rep(0, 1), rep(0, 1), rep(0,1))
names(all_mean_sd_sem) <- c("cl", "cnb", "mean", "sd", "sem")
for(cnb in cnb_measure_names_list){
  for(num in 1:length(numeric_vector)) {
    clst <- groups_list[num,1]
    meas <- groups_list[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sd_grp
    sem_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")))", sep="")
    sem_grp <- eval(parse(text=as.name(sem_for_eval)))
    all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sem_grp
  }
}


#add sems to cnb_measures_for_plot

names(all_mean_sd_sem) <- c("cluster", "cnb", "mean", "sd", "sem")

ggplot(data = all_mean_sd_sem, aes(x = cnb, y = mean, group = cluster)) + ylab("Mean Z-score") + xlab("Summary Scores") + 
  ggtitle("CNB Measures") + 
  geom_line(aes(color=cluster, size=.1), show.legend = F) +
  geom_point(aes(color=cluster)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(name = " ") +
  scale_y_continuous(limits=c(-1.1,1.1)) + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 30, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

####Accuracy alone####
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
numeric_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups_list <- data.frame(cbind(c(cluster_titles), c(numeric_vector)))
names(groups_list) <- c("cl", "numeric")
all_mean_sd_sem <- data.frame(rep(groups_list$cl, length(cnb_accuracy_names)), rep(cnb_accuracy_names, each = length(numeric_vector)), rep(0, 1), rep(0, 1), rep(0,1))
names(all_mean_sd_sem) <- c("cl", "cnb", "mean", "sd", "sem")
for(cnb in cnb_accuracy_names){
  for(num in 1:length(numeric_vector)) {
    clst <- groups_list[num,1]
    meas <- groups_list[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sd_grp
    sem_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")))", sep="")
    sem_grp <- eval(parse(text=as.name(sem_for_eval)))
    all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sem_grp
  }
}

#add sems to cnb_measures_for_plot
names(all_mean_sd_sem) <- c("cluster", "cnb", "mean", "sd", "sem")
accuracy_names_no_z <- gsub("_z", "", cnb_accuracy_names)
accuracy_full_names <- extended_names[1:12,2]

  ggplot(data = all_mean_sd_sem, aes(x = factor(cnb, level = cnb_accuracy_names), y = mean, group = cluster)) + ylab("Mean Z-score") + xlab("Accuracy") + 
  ggtitle("CNB Accuracy Measures") + 
  geom_line(aes(color=cluster, size=.1), show.legend = F) +
  geom_point(aes(color=cluster)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(labels=accuracy_full_names, name = " ") +
  scale_y_continuous(limits=c(-0.8,1.1)) + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 25, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        axis.line.x = element_line(size = 2),
        axis.line.y = element_line(size = 2),
        axis.ticks = element_line(colour = "black", size = 2),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.position = "top",
        legend.title=element_blank())

####Speed alone####
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
numeric_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups_list <- data.frame(cbind(c(cluster_titles), c(numeric_vector)))
names(groups_list) <- c("cl", "numeric")
all_mean_sd_sem <- data.frame(rep(groups_list$cl, length(cnb_speed_names)), rep(cnb_speed_names, each = length(numeric_vector)), rep(0, 1), rep(0, 1), rep(0,1))
names(all_mean_sd_sem) <- c("cl", "cnb", "mean", "sd", "sem")
for(cnb in cnb_speed_names){
  for(num in 1:length(numeric_vector)) {
    clst <- groups_list[num,1]
    meas <- groups_list[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sd_grp
    sem_for_eval <- paste("sd(subset_with_clusters_AG_matched$", cnb, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")])/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups_list[num,2], ")))", sep="")
    sem_grp <- eval(parse(text=as.name(sem_for_eval)))
    all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$cnb == cnb)] <- sem_grp
  }
}


#add sems to cnb_measures_for_plot
names(all_mean_sd_sem) <- c("cluster", "cnb", "mean", "sd", "sem")
# string manipulation to get pretty labels
speed_names_no_s_z <- gsub("_s_z", "", cnb_speed_names)
speed_full_names <- extended_names[13:26,2]

ggplot(data = all_mean_sd_sem, aes(x = factor(cnb, level = cnb_speed_names), y = mean, group = cluster)) + ylab("Mean Z-score") + xlab("Summary Scores") + 
  ggtitle("CNB Speed Measures") + 
  geom_line(aes(color=cluster, size=.1), show.legend = F) +
  geom_point(aes(color=cluster)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(labels=speed_full_names, name = " ") +
  scale_y_continuous(limits=c(-0.8, 1.1)) + 
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 25, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        axis.line.x = element_line(size = 2),
        axis.line.y = element_line(size = 2),
        axis.ticks = element_line(colour = "black", size = 2),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.position = "none")

```

```{r clinical_bifactor}
#######################################################
############ READ IN, MERGE AND SUBSET DATA############
#######################################################
#set defaults
num_clusters <- 3
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)

#read in csvs
demographics <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv
#clinical_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_goassess_itemwise_bifactor_scores_20161219.csv", header = TRUE, sep = ",") 
clinical_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/GOA_factor_scores_NO_DEPRESSION.csv", header = TRUE, sep = ",") 
health <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_health_20170405.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_health_20170405.csv
psych_summary <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv

#from /data/joy/BBL/studies/pnc/n1601_dataFreeze/clinical/n1601_stai_pre_post_itemwise_smry_factors_20170131.csv

#read in Hydra cluster data -> AG (all_gender), M(males), F(females) 
hydra_AG_matched_clusters <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/hydra_output_from_cbica/hydra_matched/20181121_OLD_HYDRA_with_new_script_from_toni/CogData_age_and_sex_n1424_matched_imaging_plus_non_imaging_replication_20181121_HydraSubtypes.csv", header = TRUE, sep = ",")

#Coerce hydra values into factor format
hydra_names <- names(hydra_AG_matched_clusters[2:11])
hydra_AG_matched_clusters[hydra_names] <- lapply(hydra_AG_matched_clusters[hydra_names], factor)


############
#prepping and merging big clinical and demographics stuff
############

#remove people with NA for race, age, or sex.  START WITH N = 9498
demographics_noNA_race <- demographics[!is.na(demographics$race),] #everyone has a race, N = 9498
demographics_noNA_race_age <- demographics_noNA_race[!is.na(demographics_noNA_race$ageAtClinicalAssess1),] # 86 people do not have age at clinical assessment.  N = 9412
demographics_noNA_race_age_sex <- demographics_noNA_race_age[!is.na(demographics_noNA_race_age$sex),] #everyone has a sex, N = 9412

#remove people with NA for depression or total psych score, START WITH N = 9498
psych_summary_no_NA_dep <- psych_summary[!is.na(psych_summary$smry_dep),] #take out those with NA for depression, 87 people N = 9411
psych_summary_no_NA_dep_and_smry_psych_overall <- psych_summary_no_NA_dep[!is.na(psych_summary_no_NA_dep$smry_psych_overall_rtg),] #take out those with NA for overall psych rtg, no additional people lost, N = 9411

#merge demographics and clinical #this is if we want to include people without full demographic data
dem_clinical <- merge(demographics_noNA_race_age_sex, clinical_scores, by = "bblid") #merge demographics and clinical, N = 9350
psych_health <- merge(psych_summary_no_NA_dep_and_smry_psych_overall, health, by = "bblid") #merge psych and health, N = 9411
dem_clinical_psych_health_merged <- merge (dem_clinical, psych_health, by = "bblid") #merge all 3 csvs, lost 1 person [134716] (had demographics, but no psych ratings): N = 9350

#make subsets
subset_just_dep_and_no_medicalratingExclude <- subset.data.frame(dem_clinical_psych_health_merged, (medicalratingExclude == 0) & (smry_dep == 4), select = "bblid") #subset people who were not medically excluded and who are depressed, N = 776
subset_no_psych_no_medicalratingExclude <- subset.data.frame(dem_clinical_psych_health_merged, (medicalratingExclude == 0) & (smry_psych_overall_rtg < 4), select = "bblid") #subset people who are psychiatrically healthy, N = 2508
subset_dep_or_no_psych_and_no_medicalratingExclude <- subset.data.frame(dem_clinical_psych_health_merged, (medicalratingExclude == 0) & ((smry_dep == 4) | (smry_psych_overall_rtg <4))) #subset including both depressed and healthies, good for regressions, N = 3284

#would binarize depression smry score to -1 (less than 4, not depressed) and 1 (score 4 , depressed)
dep_binarized <- ifelse(subset_dep_or_no_psych_and_no_medicalratingExclude$smry_dep == 4, 1, -1)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- cbind(subset_dep_or_no_psych_and_no_medicalratingExclude, dep_binarized) #N = 3284

#make depression and gender into factor scores
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex)

#divide ageAtclinical by 12 for age
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageAtClinicalAssess1/12

#race binarized for plotting purposes, caucasian 1, non-caucasion 0
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race_binarized <- ifelse(as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race) == 1, 1, 0)

#add age squared mean-centered term for use in LM
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageSq <- as.numeric(I(scale(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years, scale = FALSE, center = TRUE)^2))

#remove people with NA in their clinical measures
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[complete.cases(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[14:39]),]

################################################
### Merge clustering data with subsetted data ##
################################################

#AG (all gender), M (males), F (females) 
#AG Matched - n 1424

subset_with_clusters_AG_matched <- merge(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED, hydra_AG_matched_clusters, by = "bblid")
clusters <- names(subset_with_clusters_AG_matched[grep ("Hydra", names(subset_with_clusters_AG_matched))])

#### Demographics
make_demographics_table(data_frame = subset_with_clusters_AG_matched, hydra_cluster = num_clusters)

####

#################################
# Linear Model for each measure #
##### Results stored in list ####
#################################

#get clinical measure names
clinical_measure_names <- names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED)[grep("Bifactor", names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED))] #get the names of all the columns with factorv2 in the name
clinical_measure_names <- clinical_measure_names[-grep("_ar", clinical_measure_names)] #only look at NON-age regressed
cluster_names <- colnames(hydra_AG_matched_clusters[,2:11])

# <- names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED)[grep("Bifactor", #names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED))]  #get the names of all the columns with factorv2 in the name
#clinical_measure_names_list <- clinical_measure_names_list[-grep("_ar", clinical_measure_names_list)]
#cluster_names_list <- colnames(hydra_AG_matched_clusters[,2:11])

#lm ageSq and mean centered
clinical_score_cluster_stats_lm_agesq_AG_matched <- lapply(clinical_measure_names, function(x) 
{
  lm(substitute(i ~ Hydra_k3 + sex + age_in_years + ageSq , list(i = as.name(x))), data = subset_with_clusters_AG_matched)
})
names(clinical_score_cluster_stats_lm_agesq_AG_matched) <- clinical_measure_names


#lm Hydra K3 Anova
clinical_score_cluster_stats_anova_lm_agesq_AG_matched <- lapply(clinical_score_cluster_stats_lm_agesq_AG_matched, anova) 
names(clinical_score_cluster_stats_anova_lm_agesq_AG_matched) <- clinical_measure_names

############################################
########          Plotting          ########
############################################
groups_list <- data.frame(cbind(c("TD", "Subtype 1", "Subtype 2", "Subtype 3"), c("-1", "1", "2", "3")))
names(groups_list) <- c("cl", "numeric")
all_mean_sd_sem <- data.frame(rep(groups_list$cl, 5), rep(clinical_measure_names, each = 4), rep(0, 1), rep(0, 1), rep(0,1))
names(all_mean_sd_sem) <- c("cl", "clinical", "mean", "sd", "sem")
for(clinical in clinical_measure_names){
  for(num in 1:4) {
    clst <- groups_list[num,1]
    meas <- groups_list[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", clinical, "[which(subset_with_clusters_AG_matched$Hydra_k3 == ", meas, ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$clinical == clinical)] <- mean_grp
  
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", clinical, "[which(subset_with_clusters_AG_matched$Hydra_k3 == ", groups_list[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$clinical == clinical)] <- sd_grp
    sem_for_eval <- paste("sd(subset_with_clusters_AG_matched$", clinical, "[which(subset_with_clusters_AG_matched$Hydra_k3 == ", groups_list[num,2], ")])/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k3 == ", groups_list[num,2], ")))", sep="")
    sem_grp <- eval(parse(text=as.name(sem_for_eval)))
    all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$clinical == clinical)] <- sem_grp
  }
}

#remove _4factorv2 from names
all_mean_sd_sem$clinical <- gsub("_4factorv2", "", all_mean_sd_sem$clinical)
all_mean_sd_sem$clinical <- gsub("_", " ", all_mean_sd_sem$clinical)

names(all_mean_sd_sem) <- c("cluster", "clinical", "mean", "sd", "sem")

#change bifactor names to match Toni's
clinical_bifactor_TONI_names <- c("anxious-misery", "psychosis", "behavioral", "fear", "overall psychopathology")
new_names <- rep(clinical_bifactor_TONI_names, each = 4)
all_mean_sd_sem$new_names <- new_names
upper_case <- gsub(pattern = "\\b([a-z])", replacement = "\\U\\1", all_mean_sd_sem$new_names, perl = TRUE)
all_mean_sd_sem$new_names <- upper_case

ggplot(data = all_mean_sd_sem, aes(x = clinical, y = mean, group = cluster)) + ylab("Mean Z-score")  +
  ggtitle("Clinical Bifactor Scores") + 
  geom_line(aes(color=cluster, size=.1), show.legend = F) +
  geom_point(aes(color=cluster)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(limits=all_mean_sd_sem$clinical, labels=all_mean_sd_sem$new_names, name = " ") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, hjust = 1, angle = 60), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

###################################################
#####              FDR Correction             #####
###################################################

## Extracting anovas with significant p values ####

#model summary
models_anova_lm_agesq <- lapply(clinical_score_cluster_stats_anova_lm_agesq_AG_matched, summary)

#Pull p-values
p_anova_lm_agesq <- sapply(clinical_score_cluster_stats_anova_lm_agesq_AG_matched, function(v) v$"Pr(>F)"[1]) #$coef[,"Pr(>F)"][2]) #get the p value for dep binarized

#Convert to data frame
p_anova_lm_agesq <- as.data.frame(p_anova_lm_agesq)

#Print original p-values to three decimal places
p_round_anova_lm_agesq <- round(p_anova_lm_agesq,3)

#FDR correct p-values
pfdr_anova_lm_agesq <- p.adjust(p_anova_lm_agesq[,1],method="fdr")

#Convert to data frame
pfdr_anova_lm_agesq <- as.data.frame(pfdr_anova_lm_agesq)
row.names(pfdr_anova_lm_agesq) <- clinical_measure_names

#To print fdr-corrected p-values to three decimal places
pfdr_round_anova_lm_agesq <- round(pfdr_anova_lm_agesq,3)

#List the NMF components that survive FDR correction
clinical_fdr_anova_lm_agesq <- row.names(pfdr_anova_lm_agesq)[pfdr_anova_lm_agesq<0.05]

#make a data frame with names and fdr values (rounded to 3 decimals)
clinical_names_and_fdr_values_anova_lm_agesq <- data.frame(cbind(clinical_fdr_anova_lm_agesq, round(pfdr_anova_lm_agesq[pfdr_anova_lm_agesq<0.05],3)))

#add titles to names_and_fdr tables
names(clinical_names_and_fdr_values_anova_lm_agesq) <- c("clinical_measure", "p_FDR_corr")

print("LM Agesq- Mean centered age that was then squared")
print(clinical_names_and_fdr_values_anova_lm_agesq)

######################################################
####Pairwise t-tests for anova-corrected lm means ####
######################################################

#put lm model into emmeans format
clinical_emmodel_lm_agesq_AG_matched <- lapply(clinical_score_cluster_stats_lm_agesq_AG_matched, function(x) {as.list(ref_grid(x))})
clinical_emmgrid_lm_agesq_AG_matched <- lapply(clinical_emmodel_lm_agesq_AG_matched, function(x) {as.emmGrid(x)})

#run emmeans, do not include values that were not FDR corrected
clinical_emmeans_lm_agesq_AG_matched <- lapply(clinical_emmgrid_lm_agesq_AG_matched, function(x) {emmeans(x, "Hydra_k3")})

#run pairwise contrasts
clinical_emmpairs_lm_agesq_AG_matched <- lapply(clinical_emmeans_lm_agesq_AG_matched, function(x) {pairs(x)})

#Only include stuff that was fdr corrected (i.e., only keep parts of the model (or only display) ones that are corrected)
clinical_emmpairs_lm_agesq_AG_matched_FDR_corrected <- clinical_emmpairs_lm_agesq_AG_matched[c(clinical_fdr_anova_lm_agesq)]

######Make table of contrasts, rows are names of clinical measures that are fdr corrected, columns are contrasts, values are pvalues

#contrast names, -1 = controls, 1-3 are clusters
contrast_names <- c("-1 - 1", "-1 - 2", "-1 - 3", "1 - 2", "1 - 3", "2 - 3")

#go through each fdr corrected clinical measure, and extract p values
contrast_table <- lapply(clinical_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {round(summary(x)$p.value,3)})

#get the names of the clinical measures that were fdr corrected
fdr_corrected_clinical <- names(contrast_table)

#build table that will hold the name of the clinical measure and the p values
pairwise_table <- data.frame(matrix(nrow = length(fdr_corrected_clinical), ncol = 6))

#give the appropriate names
rownames(pairwise_table) <- fdr_corrected_clinical
colnames(pairwise_table) <- contrast_names

#loop through each clinical measure, and manually assign the columns to be the p values
for (measure in fdr_corrected_clinical)
{
  pair_pval <- contrast_table[[measure]]
  pairwise_table[measure,] <- pair_pval
}

#get the 4factor2 out of the name
fdr_corrected_clinical_gsub <- gsub("_4factorv2", "", fdr_corrected_clinical)
rownames(pairwise_table) <- fdr_corrected_clinical_gsub

#add FDR correction
pairwise_table_with_fdr <- pairwise_table
pairwise_table_with_fdr$p_FDR_corr <- clinical_names_and_fdr_values_anova_lm_agesq$p_FDR_corr

#print values

print("LM Agesq pairwise contrasts with FDR corrected values, Bifactor scores")
print(pairwise_table_with_fdr)

sapply(clinical_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {print(x)})


#########################################################
#checkmodel with visreg, uncomment when want to check####
#########################################################
#invisible(lapply(clinical_score_cluster_stats_lm_agesq_AG_matched, function(x) {visreg(x)}))
```

```{r anxious_misery}

#######################################################
############ READ IN, MERGE AND SUBSET DATA############
#######################################################
#set defaults
num_clusters <- 3
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)

#read in csvs
demographics <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_demographics_go1_20161212.csv
#clinical_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_goassess_itemwise_bifactor_scores_20161219.csv", header = TRUE, sep = ",") 
#from /data/joy/BBL/studies/pnc/n1601_dataFreeze/clinical/n1601_stai_pre_post_itemwise_smry_factors_20170131.csv
clinical_scores <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n1601_stai_pre_post_itemwise_smry_factors_20170131.csv", header=TRUE, na.strings="")
health <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_health_20170405.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_health_20170405.csv
psych_summary <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv", header = TRUE, sep = ",") #from /data/joy/BBL/projects/ballerDepHeterogen/data/n9498_goassess_psych_summary_vars_20131014.csv


#read in Hydra cluster data -> AG (all_gender), M(males), F(females) 
hydra_AG_matched_clusters <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/hydra_output_from_cbica/hydra_matched/20181121_OLD_HYDRA_with_new_script_from_toni/CogData_age_and_sex_n1424_matched_imaging_plus_non_imaging_replication_20181121_HydraSubtypes.csv", header = TRUE, sep = ",")

#Coerce hydra values into factor format
hydra_names <- names(hydra_AG_matched_clusters[2:11])
hydra_AG_matched_clusters[hydra_names] <- lapply(hydra_AG_matched_clusters[hydra_names], factor)


############
#prepping and merging big clinical and demographics stuff
############

#remove people with NA for race, age, or sex.  START WITH N = 9498
demographics_noNA_race <- demographics[!is.na(demographics$race),] #everyone has a race, N = 9498
demographics_noNA_race_age <- demographics_noNA_race[!is.na(demographics_noNA_race$ageAtClinicalAssess1),] # 86 people do not have age at clinical assessment.  N = 9412
demographics_noNA_race_age_sex <- demographics_noNA_race_age[!is.na(demographics_noNA_race_age$sex),] #everyone has a sex, N = 9412

#remove people with NA for depression or total psych score, START WITH N = 9498
psych_summary_no_NA_dep <- psych_summary[!is.na(psych_summary$smry_dep),] #take out those with NA for depression, 87 people N = 9411
psych_summary_no_NA_dep_and_smry_psych_overall <- psych_summary_no_NA_dep[!is.na(psych_summary_no_NA_dep$smry_psych_overall_rtg),] #take out those with NA for overall psych rtg, no additional people lost, N = 9411

#subset clinical scores
clinical_scores <- clinical_scores[,1:4]

#merge demographics and clinical #this is if we want to include people without full demographic data
dem_clinical <- merge(demographics_noNA_race_age_sex, clinical_scores, by = "bblid") #merge demographics and clinical, N = 9350
psych_health <- merge(psych_summary_no_NA_dep_and_smry_psych_overall, health, by = "bblid") #merge psych and health, N = 9411
dem_clinical_psych_health_merged <- merge (dem_clinical, psych_health, by = "bblid") #merge all 3 csvs, lost 1 person [134716] (had demographics, but no psych ratings): N = 9350

#make subsets
subset_just_dep_and_no_medicalratingExclude <- subset.data.frame(dem_clinical_psych_health_merged, (medicalratingExclude == 0) & (smry_dep == 4), select = "bblid") #subset people who were not medically excluded and who are depressed, N = 776
subset_no_psych_no_medicalratingExclude <- subset.data.frame(dem_clinical_psych_health_merged, (medicalratingExclude == 0) & (smry_psych_overall_rtg < 4), select = "bblid") #subset people who are psychiatrically healthy, N = 2508
subset_dep_or_no_psych_and_no_medicalratingExclude <- subset.data.frame(dem_clinical_psych_health_merged, (medicalratingExclude == 0) & ((smry_dep == 4) | (smry_psych_overall_rtg <4))) #subset including both depressed and healthies, good for regressions, N = 3284

#would binarize depression smry score to -1 (less than 4, not depressed) and 1 (score 4 , depressed)
dep_binarized <- ifelse(subset_dep_or_no_psych_and_no_medicalratingExclude$smry_dep == 4, 1, -1)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- cbind(subset_dep_or_no_psych_and_no_medicalratingExclude, dep_binarized) #N = 3284

#make depression and gender into factor scores
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$dep_binarized)
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex <- as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$sex)

#divide ageAtclinical by 12 for age
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageAtClinicalAssess1/12

#race binarized for plotting purposes, caucasian 1, non-caucasion 0
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race_binarized <- ifelse(as.factor(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$race) == 1, 1, 0)

#add age squared mean-centered term for use in LM
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$ageSq <- as.numeric(I(scale(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$age_in_years, scale = FALSE, center = TRUE)^2))

#remove people with NA in their clinical measures
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED <- subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[complete.cases(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED[14:39]),]
subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$staiPreTrait <- as.numeric(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED$staiPreTrait)
################################################
### Merge clustering data with subsetted data ##
################################################

#AG (all gender), M (males), F (females) 
#AG Matched - n 1424

subset_with_clusters_AG_matched <- merge(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED, hydra_AG_matched_clusters, by = "bblid")
clusters <- names(subset_with_clusters_AG_matched[grep ("Hydra", names(subset_with_clusters_AG_matched))])

#### Demographics
make_demographics_table(data_frame = subset_with_clusters_AG_matched, hydra_cluster = num_clusters)


#################################
# Linear Model for each measure #
##### Results stored in list ####
#################################

#get clinical measure names
#clinical_measure_names <- names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED)[grep("Bifactor", names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED))] #get the names of all the columns with factorv2 in the name
#clinical_measure_names <- clinical_measure_names[-grep("_ar", clinical_measure_names)] #only look at NON-age regressed
clinical_measure_names <- c("staiPreState", "staiPreTrait")
cluster_names <- colnames(hydra_AG_matched_clusters[,2:11])

# <- names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED)[grep("Bifactor", #names(subset_dep_or_no_psych_and_no_medicalratingExclude_DEPBINARIZED))]  #get the names of all the columns with factorv2 in the name
#clinical_measure_names_list <- clinical_measure_names_list[-grep("_ar", clinical_measure_names_list)]
#cluster_names_list <- colnames(hydra_AG_matched_clusters[,2:11])

#lm ageSq and mean centered
clinical_score_cluster_stats_lm_agesq_AG_matched <- lapply(clinical_measure_names, function(x) 
{
  lm(substitute(i ~ Hydra_k3 + sex + age_in_years + ageSq , list(i = as.name(x))), data = subset_with_clusters_AG_matched)
})
names(clinical_score_cluster_stats_lm_agesq_AG_matched) <- clinical_measure_names


#lm Hydra K3 Anova
clinical_score_cluster_stats_anova_lm_agesq_AG_matched <- lapply(clinical_score_cluster_stats_lm_agesq_AG_matched, anova) 
names(clinical_score_cluster_stats_anova_lm_agesq_AG_matched) <- clinical_measure_names

############################################
########          Plotting          ########
############################################
groups_list <- data.frame(cbind(c("TD", "Subtype 1", "Subtype 2", "Subtype 3"), c("-1", "1", "2", "3")))
names(groups_list) <- c("cl", "numeric")
all_mean_sd_sem <- data.frame(rep(groups_list$cl, 2), rep(clinical_measure_names, each = 4), rep(0, 1), rep(0, 1), rep(0,1))
names(all_mean_sd_sem) <- c("cl", "clinical", "mean", "sd", "sem")
for(clinical in clinical_measure_names){
  for(num in 1:4) {
    clst <- groups_list[num,1]
    meas <- groups_list[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", clinical, "[which(subset_with_clusters_AG_matched$Hydra_k3 == ", meas, ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$clinical == clinical)] <- mean_grp
  
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", clinical, "[which(subset_with_clusters_AG_matched$Hydra_k3 == ", groups_list[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$clinical == clinical)] <- sd_grp
    sem_for_eval <- paste("sd(subset_with_clusters_AG_matched$", clinical, "[which(subset_with_clusters_AG_matched$Hydra_k3 == ", groups_list[num,2], ")])/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k3 == ", groups_list[num,2], ")))", sep="")
    sem_grp <- eval(parse(text=as.name(sem_for_eval)))
    all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$clinical == clinical)] <- sem_grp
  }
}


names(all_mean_sd_sem) <- c("cluster", "clinical", "mean", "sd", "sem")

#change bifactor names to match Toni's
clinical_bifactor_TONI_names <- c("State Anxiety", "Trait Anxiety")
new_names <- rep(clinical_bifactor_TONI_names, each = 4)
all_mean_sd_sem$new_names <- new_names

ggplot(data = all_mean_sd_sem, aes(x = clinical, y = mean, group = cluster)) + ylab("Mean Anxiety Score")  +
  ggtitle("State and Trait Anxiety Scores") + 
  geom_line(aes(color=cluster, size=.1), show.legend = F) +
  geom_point(aes(color=cluster)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(limits=all_mean_sd_sem$clinical, labels=all_mean_sd_sem$new_names, name = " ") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, hjust = 1, angle = 60), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

###################################################
#####              FDR Correction             #####
###################################################

## Extracting anovas with significant p values ####

#model summary
models_anova_lm_agesq <- lapply(clinical_score_cluster_stats_anova_lm_agesq_AG_matched, summary)

#Pull p-values
p_anova_lm_agesq <- sapply(clinical_score_cluster_stats_anova_lm_agesq_AG_matched, function(v) v$"Pr(>F)"[1]) #$coef[,"Pr(>F)"][2]) #get the p value for dep binarized

#Convert to data frame
p_anova_lm_agesq <- as.data.frame(p_anova_lm_agesq)

#Print original p-values to three decimal places
p_round_anova_lm_agesq <- round(p_anova_lm_agesq,3)

#FDR correct p-values
pfdr_anova_lm_agesq <- p.adjust(p_anova_lm_agesq[,1],method="fdr")

#Convert to data frame
pfdr_anova_lm_agesq <- as.data.frame(pfdr_anova_lm_agesq)
row.names(pfdr_anova_lm_agesq) <- clinical_measure_names

#To print fdr-corrected p-values to three decimal places
pfdr_round_anova_lm_agesq <- round(pfdr_anova_lm_agesq,3)

#List the NMF components that survive FDR correction
clinical_fdr_anova_lm_agesq <- row.names(pfdr_anova_lm_agesq)[pfdr_anova_lm_agesq<0.05]

#make a data frame with names and fdr values (rounded to 3 decimals)
clinical_names_and_fdr_values_anova_lm_agesq <- data.frame(cbind(clinical_fdr_anova_lm_agesq, round(pfdr_anova_lm_agesq[pfdr_anova_lm_agesq<0.05],3)))

#add titles to names_and_fdr tables
names(clinical_names_and_fdr_values_anova_lm_agesq) <- c("clinical_measure", "p_FDR_corr")

print("LM Agesq- Mean centered age that was then squared")
print(clinical_names_and_fdr_values_anova_lm_agesq)

######################################################
####Pairwise t-tests for anova-corrected lm means ####
######################################################

#put lm model into emmeans format
clinical_emmodel_lm_agesq_AG_matched <- lapply(clinical_score_cluster_stats_lm_agesq_AG_matched, function(x) {as.list(ref_grid(x))})
clinical_emmgrid_lm_agesq_AG_matched <- lapply(clinical_emmodel_lm_agesq_AG_matched, function(x) {as.emmGrid(x)})

#run emmeans, do not include values that were not FDR corrected
clinical_emmeans_lm_agesq_AG_matched <- lapply(clinical_emmgrid_lm_agesq_AG_matched, function(x) {emmeans(x, "Hydra_k3")})

#run pairwise contrasts
clinical_emmpairs_lm_agesq_AG_matched <- lapply(clinical_emmeans_lm_agesq_AG_matched, function(x) {pairs(x)})

#Only include stuff that was fdr corrected (i.e., only keep parts of the model (or only display) ones that are corrected)
clinical_emmpairs_lm_agesq_AG_matched_FDR_corrected <- clinical_emmpairs_lm_agesq_AG_matched[c(clinical_fdr_anova_lm_agesq)]

######Make table of contrasts, rows are names of clinical measures that are fdr corrected, columns are contrasts, values are pvalues

#contrast names, -1 = controls, 1-3 are clusters
contrast_names <- c("-1 - 1", "-1 - 2", "-1 - 3", "1 - 2", "1 - 3", "2 - 3")

#go through each fdr corrected clinical measure, and extract p values
contrast_table <- lapply(clinical_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {round(summary(x)$p.value,3)})

#get the names of the clinical measures that were fdr corrected
fdr_corrected_clinical <- names(contrast_table)

#build table that will hold the name of the clinical measure and the p values
pairwise_table <- data.frame(matrix(nrow = length(fdr_corrected_clinical), ncol = 6))

#give the appropriate names
rownames(pairwise_table) <- fdr_corrected_clinical
colnames(pairwise_table) <- contrast_names

#loop through each clinical measure, and manually assign the columns to be the p values
for (measure in fdr_corrected_clinical)
{
  pair_pval <- contrast_table[[measure]]
  pairwise_table[measure,] <- pair_pval
}

#get the 4factor2 out of the name
fdr_corrected_clinical_gsub <- gsub("_4factorv2", "", fdr_corrected_clinical)
rownames(pairwise_table) <- fdr_corrected_clinical_gsub

#add FDR correction
pairwise_table_with_fdr <- pairwise_table
pairwise_table_with_fdr$p_FDR_corr <- clinical_names_and_fdr_values_anova_lm_agesq$p_FDR_corr

#print values

print("LM Agesq pairwise contrasts with FDR corrected values, Bifactor scores")
print(pairwise_table_with_fdr)

sapply(clinical_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {print(x)})


#########################################################
#checkmodel with visreg, uncomment when want to check####
#########################################################
#invisible(lapply(clinical_score_cluster_stats_lm_agesq_AG_matched, function(x) {visreg(x)}))
```

```{r N-back}
#######################################################
############ READ IN, MERGE AND SUBSET DATA############
#######################################################

num_clusters <- 3
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)

#read in csvs
#nback_Factors <- readRDS("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/neuroimaging/nback/nbackFactors_n1601_subjData_20150506.rds")

dem_and_cluster_data <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/subset_with_T1_NbackFC_and_dem_with_clusters_20181121_OLD_HYDRA_with_new_script_from_toni.csv", header = TRUE, sep = " ")

new_nback_extracted_vals_from_jneurosci <- read.table("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/neuroimaging/nback/parcels/mean_activation_by_27roi_by_SCANID.csv", header = TRUE)

#Get cluster and parcellation names
clusters <- names(dem_and_cluster_data[grep ("Hydra", names(dem_and_cluster_data))])
parcellations <- names(new_nback_extracted_vals_from_jneurosci[grep ("nback_func_sc", names(new_nback_extracted_vals_from_jneurosci))])



#get number of measures (to be used later on when trying to make graphs), for every different modality WILL HAVE TO CHANGE THIS
num_measures <- length(parcellations)

#Coerce values into factor format
hydra_names <- clusters

dem_and_cluster_data[hydra_names] <- lapply(dem_and_cluster_data[clusters], factor)
dem_and_cluster_data$sex <- as.factor(dem_and_cluster_data$sex)
dem_and_cluster_data$race <- as.factor(dem_and_cluster_data$race)

#merge
subset_with_clusters_AG_matched <- merge(dem_and_cluster_data, new_nback_extracted_vals_from_jneurosci, by="scanid")

#### demographics ###
make_demographics_table(data_frame = subset_with_clusters_AG_matched, hydra_cluster = num_clusters)

#################################
# Linear Model for each measure #
##### Results stored in list ####
#################################

#lm ageSq and mean centered
parcellation_cluster_stats_lm_agesq_AG_matched <- lapply(parcellations, function(parcellation) 
{
  lm(substitute(i ~ Hydra_k3 + sex + age_in_years + ageSq + nbackRelMeanRMSMotion, list(i = as.name(parcellation))), data = subset_with_clusters_AG_matched)
})
names(parcellation_cluster_stats_lm_agesq_AG_matched) <- parcellations

#lm Hydra K3 Anova
parcellation_cluster_stats_anova_lm_agesq_AG_matched <- lapply(parcellation_cluster_stats_lm_agesq_AG_matched, anova) 
names(parcellation_cluster_stats_anova_lm_agesq_AG_matched) <- parcellations

#####################################
###### By FC Connectivity Measure ###############
#####################################
#can do with all gender as well, as well as matched/unmatched, etc
#loop through each cluster and each parcellation measure, make text and evaluate the following: mean of each cluster by measure, and sd of each cluster by measure

cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
cluster_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups <- data.frame(cbind(cluster_titles, cluster_vector))
names(groups) <- c("cl", "numeric")
total_num_groups <- num_clusters + 1

#construct data frame of names of connectivity groups
df_names <- data.frame(rep(groups$cl, num_measures), rep(parcellations, each = total_num_groups))
names(df_names) <- c("cl", "parcellation")

#construct mean_sd_sem data frame
df_mean_sd_sem <- NULL
for(parcellation in parcellations) {
  mean_sd_sem <- data_frame_mean_sd_sem(data_frame = subset_with_clusters_AG_matched, variable = parcellation, hydra_cluster = num_clusters)
  df_mean_sd_sem <- rbind(df_mean_sd_sem, mean_sd_sem)
}

#combine data frames and remove the extra cluster names
all_mean_sd_sem <- data.frame(df_names, df_mean_sd_sem)
all_mean_sd_sem <- subset(all_mean_sd_sem, select = -c(cl.1))
                          
for(parcellation in parcellations){
  for(num in 1:total_num_groups) {
    clst <- groups[num,1]
    meas <- groups[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- sd_grp
  #  all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)]/sqrt(nrow(subset_with_clusters_AG_matched))
    
    #THIS WAS CHANGED 8/8, sem should be based on the number of subjects in each group!
    sem_calc <- paste0("all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)]/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters," == meas)))")
    eval(parse(text=as.name(sem_calc)))
  
  }
}

#lets do some parcellation reorganization
parcellations_newNames <- gsub("nback_func_sc_", "", parcellations) #removes the nback_func_sc_
parcellations_newNames <- gsub("_", " ", parcellations_newNames) #converts underscores to spaces
parcellations_newNames <- gsub(" r", " Right", parcellations_newNames) #converts r to Right
parcellations_newNames <- gsub(" l", " Left", parcellations_newNames) #converts l to Left
parcellations_newNames <- gsub("ant", "Anterior", parcellations_newNames) #converts ant to Anterior
parcellations_newNames <- gsub("post", "Posterior", parcellations_newNames) #converts post to Posterior
parcellations_newNames <- gsub("hipp", "hippocampus", parcellations_newNames)
parcellations_newNames <- gsub("rusI", "rus I", parcellations_newNames)
parcellations_newNames <- gsub("fp", "Frontal Pole", parcellations_newNames)
parcellations_newNames <- gsub("mfg", "dorsal frontal", parcellations_newNames)
parcellations_newNames <- gsub("precun", "precuneus", parcellations_newNames)
parcellations_newNames <- gsub("pcc", "posterior cingulate cortex", parcellations_newNames)
#parcellations_newNames <- gsub("pcc", "PCC", parcellations_newNames)
#parcellations_newNames <- gsub("dacc", "dACC", parcellations_newNames)
#parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
#parcellations_newNames <- gsub("vmpfc", "VMPFC", parcellations_newNames)
parcellations_newNames <- gsub("dacc", "anterior cingulate", parcellations_newNames)
parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
parcellations_newNames <- gsub("vmpfc", "vmPFC", parcellations_newNames)
parcellations_newNames <- gsub("thal", "thalamus", parcellations_newNames)
parcellations_newNames <- gsub(pattern = "\\b([a-z])", replacement = "\\U\\1", parcellations_newNames, perl = TRUE)
parcellations_newNames <- gsub("Vmpfc", "vmPFC", parcellations_newNames)
to_add <- rep(parcellations_newNames, each = num_clusters + 1)
all_mean_sd_sem$newNames <- to_add

#plot
ggplot(data = all_mean_sd_sem, aes(x = newNames, y = mean, group = cl)) + ylab("% Signal Change") +  
  ggtitle("N-back Functional Regions of Interest") + 
  geom_line(aes(color=cl, size=.1), show.legend = F) +
#  geom_line(aes(color=cl), show.legend = F) +
  geom_point(aes(color=cl)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
 # geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1) +
  scale_x_discrete(name = " ") + labs(colour = "cluster") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

###################################################
## Extracting anovas with significant p values ####
###################################################
#Look at model summaries
models_anova_lm_agesq <- lapply(parcellation_cluster_stats_anova_lm_agesq_AG_matched, summary)

#Pull p-values
p_anova_lm_agesq <- sapply(parcellation_cluster_stats_anova_lm_agesq_AG_matched, function(v) v$"Pr(>F)"[1]) 
f_anova_lm_agesq <- sapply(parcellation_cluster_stats_anova_lm_agesq_AG_matched, function(v) v$"F value"[1])

#$coef[,"Pr(>F)"][2]) #get the p value for dep binarized

#Convert to data frame
p_anova_lm_agesq <- as.data.frame(p_anova_lm_agesq)
f_anova_lm_agesq <- as.data.frame(f_anova_lm_agesq)

#print BEFORE FDR correction 
print("LM Agesq anova scores, BEFORE FDR correction: i.e., uncorrected")
print(p_anova_lm_agesq)

#print("LM agesq anova scores, BEFORE FDR correction, p <0.05")
#anova_before_correction_p05 <- as.data.frame(p_anova_lm_agesq[p_anova_lm_agesq <0.05])
#row.names(anova_before_correction_p05) <- row.names(anova_before_correction_p05)[p_round_anova_lm_agesq<0.05]


#Print original p-values to three decimal places
p_round_anova_lm_agesq <- round(p_anova_lm_agesq,3)

#FDR correct p-values
pfdr_anova_lm_agesq <- p.adjust(p_anova_lm_agesq[,1],method="fdr")

#Convert to data frame
pfdr_anova_lm_agesq <- as.data.frame(pfdr_anova_lm_agesq)

#keep Fs only for p's that were FDR corrected and less than 0.05 and zero out the rest

fs_fdr_corrected_with0s <- f_anova_lm_agesq
fs_fdr_corrected_with0s[which(pfdr_anova_lm_agesq >= 0.05),] <- 0 
fs_fdr_corrected_index <- which(fs_fdr_corrected_with0s > 0)
fs_fdr_corrected_vals <- fs_fdr_corrected_with0s[which(fs_fdr_corrected_with0s > 0),]
fs_fdr_corrected <- data.frame(cbind(fs_fdr_corrected_vals, fs_fdr_corrected_index))

#write csv for BrainNet
write.table(pfdr_anova_lm_agesq, '/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/nback_fdr_corr_forBrainNet.csv', col.names = FALSE, quote=FALSE, sep=",")

write.table(fs_fdr_corrected_with0s$f_anova_lm_agesq,'/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/nback_f_fdr_corr0s_forBrainNet.csv', col.names = FALSE, quote=FALSE, sep=",")

write.table(fs_fdr_corrected, '/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/nback_f_fdr_corr_forBrainNet.csv', col.names = FALSE, quote=FALSE, sep=",", row.names = FALSE)


#change row names
row.names(pfdr_anova_lm_agesq) <- parcellations

#To print fdr-corrected p-values to three decimal places
pfdr_round_anova_lm_agesq <- round(pfdr_anova_lm_agesq,3)

#List the components that survive FDR correction
parcellation_fdr_anova_lm_agesq <- row.names(pfdr_anova_lm_agesq)[pfdr_anova_lm_agesq<0.05]

#make a data frame with names and fdr values (rounded to 3 decimals)
parcellation_names_and_fdr_values_anova_lm_agesq <- data.frame(cbind(parcellation_fdr_anova_lm_agesq, round(pfdr_anova_lm_agesq[pfdr_anova_lm_agesq<0.05],3)))

#add titles to names_and_fdr tables
names(parcellation_names_and_fdr_values_anova_lm_agesq) <- c("parcellation", "p_FDR_corr")

print("LM Agesq- Mean centered age that was then squared, FDR corrected")
print(parcellation_names_and_fdr_values_anova_lm_agesq)

######################################################
####Pairwise t-tests for anova-corrected lm means ####
######################################################
#######THIS ONLY WORKS FOR 3 CLUSTERS

#put lm model into emmeans format
parcellation_emmodel_lm_agesq_AG_matched <- lapply(parcellation_cluster_stats_lm_agesq_AG_matched, function(x) {as.list(ref_grid(x))})
parcellation_emmgrid_lm_agesq_AG_matched <- lapply(parcellation_emmodel_lm_agesq_AG_matched, function(x) {as.emmGrid(x)})

#run emmeans
parcellation_emmeans_lm_agesq_AG_matched <- lapply(parcellation_emmgrid_lm_agesq_AG_matched, function(x) {emmeans(x, "Hydra_k3")})

#run pairwise contrasts
parcellation_emmpairs_lm_agesq_AG_matched <- lapply(parcellation_emmeans_lm_agesq_AG_matched, function(x) {pairs(x)})

#Only include stuff that was fdr corrected (i.e., only keep parts of the model (or only display) ones that are corrected),this will be null if nothing was corrected
parcellation_emmpairs_lm_agesq_AG_matched_FDR_corrected <- parcellation_emmpairs_lm_agesq_AG_matched[c(parcellation_fdr_anova_lm_agesq)]


################
  ####Corrected #######
######Make table of contrasts, rows are names of brain regions that are fdr corrected, columns are contrasts, values are pvalues

#contrast names, -1 = controls, 1-3 are clusters
contrast_names <- c("-1 - 1", "-1 - 2", "-1 - 3", "1 - 2", "1 - 3", "2 - 3")
#contrast_names <- c("-1 - 1", "-1 - 2", "1 2")

#go through each fdr corrected brain region, and extract p values
contrast_table <- lapply(parcellation_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {round(summary(x)$p.value,3)})
#get the names of the brain regions that were fdr corrected
fdr_corrected_brain_regions <- names(contrast_table)

#build table that will hold the name of the brain region and the p values
pairwise_table <- data.frame(matrix(nrow = length(fdr_corrected_brain_regions), ncol = 6))
#pairwise_table <- data.frame(matrix(nrow = length(fdr_corrected_brain_regions), ncol = 3))

#give the appropriate names
rownames(pairwise_table) <- fdr_corrected_brain_regions
colnames(pairwise_table) <- contrast_names

#loop through each brain region, and manually assign the columns to be the p values
for (region in fdr_corrected_brain_regions)
{
  pair_pval <- contrast_table[[region]]
  pairwise_table[region,] <- pair_pval
}

#get the mprage out of the name

#Add FDR correction
pairwise_table_with_fdr <- pairwise_table
pairwise_table_with_fdr$p_FDR_corr <- parcellation_names_and_fdr_values_anova_lm_agesq$p_FDR_corr

#print values
#print("LM Agesq pairwise contrasts for FDR corrected values Jneurosci parcellations")
#print(pairwise_table)

print ("LM Agesq pairwise contrasts and FDR corrrected values Jneurosci parcellations")
print(pairwise_table_with_fdr)

sapply(parcellation_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {print(x)})

####### Other graphs ######
parcellations <- row.names(pairwise_table_with_fdr)
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
cluster_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups <- data.frame(cbind(cluster_titles, cluster_vector))
names(groups) <- c("cl", "numeric")
total_num_groups <- num_clusters + 1
num_measures <- length(parcellations)

#construct data frame of names of connectivity groups
df_names <- data.frame(rep(groups$cl, num_measures), rep(parcellations, each = total_num_groups))
names(df_names) <- c("cl", "parcellation")

#construct mean_sd_sem data frame
df_mean_sd_sem <- NULL
for(parcellation in parcellations) {
  mean_sd_sem <- data_frame_mean_sd_sem(data_frame = subset_with_clusters_AG_matched, variable = parcellation, hydra_cluster = num_clusters)
  df_mean_sd_sem <- rbind(df_mean_sd_sem, mean_sd_sem)
}

#combine data frames and remove the extra cluster names
all_mean_sd_sem <- data.frame(df_names, df_mean_sd_sem)
all_mean_sd_sem <- subset(all_mean_sd_sem, select = -c(cl.1))
                          
for(parcellation in parcellations){
  for(num in 1:total_num_groups) {
    clst <- groups[num,1]
    meas <- groups[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- sd_grp
  sem_calc <- paste0("all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)]/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters," == meas)))")
    eval(parse(text=as.name(sem_calc)))
  
  }
}

#lets do some parcellation reorganization
parcellations_newNames <- gsub("nback_func_sc_", "", parcellations) #removes the nback_func_sc_
parcellations_newNames <- gsub("_", " ", parcellations_newNames) #converts underscores to spaces
parcellations_newNames <- gsub(" r", " Right", parcellations_newNames) #converts r to Right
parcellations_newNames <- gsub(" l", " Left", parcellations_newNames) #converts l to Left
parcellations_newNames <- gsub("ant", "Anterior", parcellations_newNames) #converts ant to Anterior
parcellations_newNames <- gsub("post", "Posterior", parcellations_newNames) #converts post to Posterior
parcellations_newNames <- gsub("hipp", "hippocampus", parcellations_newNames)
parcellations_newNames <- gsub("rusI", "rus I", parcellations_newNames)
parcellations_newNames <- gsub("fp", "Frontal Pole", parcellations_newNames)
parcellations_newNames <- gsub("mfg", "dorsal frontal", parcellations_newNames)
parcellations_newNames <- gsub("precun", "precuneus", parcellations_newNames)
parcellations_newNames <- gsub("pcc", "posterior cingulate cortex", parcellations_newNames)
#parcellations_newNames <- gsub("pcc", "PCC", parcellations_newNames)
#parcellations_newNames <- gsub("dacc", "dACC", parcellations_newNames)
#parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
#parcellations_newNames <- gsub("vmpfc", "VMPFC", parcellations_newNames)
parcellations_newNames <- gsub("dacc", "anterior cingulate", parcellations_newNames)
parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
parcellations_newNames <- gsub("vmpfc", "vmPFC", parcellations_newNames)
parcellations_newNames <- gsub("thal", "thalamus", parcellations_newNames)
parcellations_newNames <- gsub(pattern = "\\b([a-z])", replacement = "\\U\\1", parcellations_newNames, perl = TRUE)
parcellations_newNames <- gsub("Vmpfc", "vmPFC", parcellations_newNames)
to_add <- rep(parcellations_newNames, each = num_clusters + 1)
all_mean_sd_sem$newNames <- to_add

#plot
ggplot(data = all_mean_sd_sem, aes(x = newNames, y = mean, group = cl)) + ylab("% Signal Change") +  
  ggtitle("N-back Functional Regions of Interest") + 
  geom_line(aes(color=cl, size=.1), show.legend = F) +
#  geom_line(aes(color=cl), show.legend = F) +
  geom_point(aes(color=cl)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
 # geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1) +
  scale_x_discrete(name = " ") + labs(colour = "cluster") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

new_order <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/all_mean_sd_sem_nback.csv")
new_order_desc <- new_order[nrow(new_order):1, ]
new_order_desc$cl <- all_mean_sd_sem$cl
ggplot(data = new_order_desc, aes(x = newNames, y = mean, group = cl)) + ylab("% Signal Change") +  
  ggtitle("N-back Functional Regions of Interest") + 
  geom_line(aes(color=cl, size=.1), show.legend = F) +
#  geom_line(aes(color=cl), show.legend = F) +
  geom_point(aes(color=cl)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
 # geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1) +
  scale_x_discrete(name = " ", limits=new_order_desc$newNames) + labs(colour = "cluster") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())
```

```{r Functional_connectivity}

#Make sample
dem_and_cluster_data <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/df_task_active_node_strength_8roi_20190206.csv")

rest_QA <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/neuroimaging/rest/n1601_RestQAData_20170714.csv")
nback_QA <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/neuroimaging/nback/n1601_NbackConnectQAData_20170718.csv")
idemo_QA <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/neuroimaging/idemo/n1601_idemo_FinalQA_092817.csv")

#fc_networks_and_dem_clinical_psych_data <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/data/output_of_fc/fc_r400_com17/fc_r400_com17.csv")

#subset_with_clusters_AG_matched - rename because this is what will be used for the rest of the script
subset_with_clusters_AG_matched <- dem_and_cluster_data

#Get cluster and parcellation names
clusters <- names(subset_with_clusters_AG_matched[grep ("Hydra", names(subset_with_clusters_AG_matched))])
parcellations <- names(subset_with_clusters_AG_matched[2:9])
subset_with_clusters_AG_matched$network_strength <- rowSums(dem_and_cluster_data[,2:9])
#parcellations <- "network_strength"

####New as of 10/21/2018 ####
#read in new hydra clusters
new_hydra_clusters <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/hydra_output_from_cbica/hydra_matched/20181121_OLD_HYDRA_with_new_script_from_toni/CogData_age_and_sex_n1424_matched_imaging_plus_non_imaging_replication_20181121_HydraSubtypes.csv", header = TRUE, sep = ",")

# remove old hydra clusters
subset_with_clusters_AG_matched <- subset_with_clusters_AG_matched[, !(colnames(subset_with_clusters_AG_matched) %in% c(clusters))]

#add new hydra clusters 
subset_with_clusters_AG_matched <- merge(subset_with_clusters_AG_matched, new_hydra_clusters, by = "bblid")

#merge with the QA measures
subset_with_clusters_AG_matched <- merge(subset_with_clusters_AG_matched, rest_QA, by = c("bblid", "scanid"))
subset_with_clusters_AG_matched <- merge(subset_with_clusters_AG_matched, nback_QA, by = c("bblid", "scanid"))
subset_with_clusters_AG_matched <- merge(subset_with_clusters_AG_matched, idemo_QA, by = c("bblid", "scanid"))

subset_with_clusters_AG_matched$ageSq <- as.numeric(I(scale(subset_with_clusters_AG_matched$age_in_years, scale = FALSE, center = TRUE)^2))
subset_with_clusters_AG_matched$dep_binarized <- subset_with_clusters_AG_matched$Hydra_k1

subset_with_clusters_AG_matched[clusters] <- lapply(subset_with_clusters_AG_matched[clusters], factor)

subset_with_clusters_AG_matched_noTD <-eval(parse(text=as.name(paste0("subset_with_clusters_AG_matched[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " != -1),]"))))

#get number of measures (to be used later on when trying to make graphs), for every different modality WILL HAVE TO CHANGE THIS
num_measures <- length(parcellations)

cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)

#Coerce values into factor format
hydra_names <- clusters

subset_with_clusters_AG_matched[hydra_names] <- lapply(subset_with_clusters_AG_matched[clusters], factor)
subset_with_clusters_AG_matched$sex <- as.factor(subset_with_clusters_AG_matched$sex)
subset_with_clusters_AG_matched$race <- as.factor(subset_with_clusters_AG_matched$race)


#demographics
make_demographics_table(data_frame = subset_with_clusters_AG_matched, hydra_cluster = num_clusters)

#################################
# Linear Model for each measure #
##### Results stored in list ####
#################################



##### Just Hydra_3 clusters ######

#lm ageSq and mean centered
parcellation_cluster_stats_lm_agesq_AG_matched <- lapply(parcellations, function(parcellation) 
{
  lm(substitute(i ~ Hydra_k3 + sex + age_in_years + ageSq + restRelMeanRMSMotion + nbackRelMeanRMSMotion + idemoRelMeanRMSMotion, list(i = as.name(parcellation))), data = subset_with_clusters_AG_matched)
})
names(parcellation_cluster_stats_lm_agesq_AG_matched) <- parcellations

#network_strength_overall
network_strength_lm <- lm(network_strength~Hydra_k3 + sex + age_in_years + ageSq + restRelMeanRMSMotion + nbackRelMeanRMSMotion + idemoRelMeanRMSMotion, data = subset_with_clusters_AG_matched)

##############################
####### Statistics ###########
##############################


#####Just Hydra 3 clusters ANOVA ########

#lm Hydra K3 Anova
parcellation_cluster_stats_anova_lm_agesq_AG_matched <- lapply(parcellation_cluster_stats_lm_agesq_AG_matched, anova) 
names(parcellation_cluster_stats_anova_lm_agesq_AG_matched) <- parcellations

#lm age sq network strength
network_strength_lm_anova <- anova(network_strength_lm)
network_strength_overall_p <- round(network_strength_lm_anova$`Pr(>F)`,3)

#####################################
###### By FC Connectivity Measure ###############
#####################################

cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
cluster_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups <- data.frame(cbind(cluster_titles, cluster_vector))
names(groups) <- c("cl", "numeric")
total_num_groups <- num_clusters + 1

#construct data frame of names of connectivity groups
df_names <- data.frame(rep(groups$cl, num_measures), rep(parcellations, each = total_num_groups))
names(df_names) <- c("cl", "parcellation")

#construct mean_sd_sem data frame
df_mean_sd_sem <- NULL
for(parcellation in parcellations) {
  mean_sd_sem <- data_frame_mean_sd_sem(data_frame = subset_with_clusters_AG_matched, variable = parcellation, hydra_cluster = num_clusters)
  df_mean_sd_sem <- rbind(df_mean_sd_sem, mean_sd_sem)
}

#combine data frames and remove the extra cluster names
all_mean_sd_sem <- data.frame(df_names, df_mean_sd_sem)
all_mean_sd_sem <- subset(all_mean_sd_sem, select = -c(cl.1))
                          
for(parcellation in parcellations){
  for(num in 1:total_num_groups) {
    clst <- groups[num,1]
    meas <- groups[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- sd_grp
    
       sem_calc <- paste0("all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)]/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters," == meas)))")
    eval(parse(text=as.name(sem_calc)))
  
  }
}

#lets do some parcellation reorganization
parcellations_newNames <- gsub("nback_func_sc_", "", parcellations) #removes the nback_func_sc_
parcellations_newNames <- gsub("_", " ", parcellations_newNames) #converts underscores to spaces
parcellations_newNames <- gsub(" r", " Right", parcellations_newNames) #converts r to Right
parcellations_newNames <- gsub(" l", " Left", parcellations_newNames) #converts l to Left
parcellations_newNames <- gsub("ant", "Anterior", parcellations_newNames) #converts ant to Anterior
parcellations_newNames <- gsub("post", "Posterior", parcellations_newNames) #converts post to Posterior
parcellations_newNames <- gsub("hipp", "hippocampus", parcellations_newNames)
parcellations_newNames <- gsub("rusI", "rus I", parcellations_newNames)
parcellations_newNames <- gsub("fp", "Frontal Pole", parcellations_newNames)
parcellations_newNames <- gsub("mfg", "dorsal frontal", parcellations_newNames)
parcellations_newNames <- gsub("precun", "precuneus", parcellations_newNames)
parcellations_newNames <- gsub("pcc", "posterior cingulate cortex", parcellations_newNames)
#parcellations_newNames <- gsub("pcc", "PCC", parcellations_newNames)
#parcellations_newNames <- gsub("dacc", "dACC", parcellations_newNames)
#parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
#parcellations_newNames <- gsub("vmpfc", "VMPFC", parcellations_newNames)
parcellations_newNames <- gsub("dacc", "anterior cingulate", parcellations_newNames)
parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
parcellations_newNames <- gsub("vmpfc", "vmPFC", parcellations_newNames)
parcellations_newNames <- gsub("thal", "thalamus", parcellations_newNames)
parcellations_newNames <- gsub(pattern = "\\b([a-z])", replacement = "\\U\\1", parcellations_newNames, perl = TRUE)
parcellations_newNames <- gsub("Vmpfc", "vmPFC", parcellations_newNames)
to_add <- rep(parcellations_newNames, each = num_clusters + 1)
all_mean_sd_sem$newNames <- to_add

#plot

ggplot(data = all_mean_sd_sem, aes(x = newNames, y = mean, group = cl)) + ylab("Node Strength") +  
  ggtitle(paste0("Node Strength in Significant Areas: Overall Network Strength = ", network_strength_overall_p)) + 
  geom_line(aes(color=cl, size=.1), show.legend = F) +
  geom_point(aes(color=cl)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(name = " ") + labs(colour = "cluster") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())


new_order <- read.csv("/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/csvs/fc_task_active.csv")

new_order$cl <- all_mean_sd_sem$cl
ggplot(data = new_order, aes(x = newNames, y = mean, group = cl)) + ylab("Nodal Strength") +  
  ggtitle("Nodal Strength- Overall Network Strength P=0.043") + 
  geom_line(aes(color=cl, size=.1), show.legend = F) +
#  geom_line(aes(color=cl), show.legend = F) +
  geom_point(aes(color=cl)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
 # geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1) +
  scale_x_discrete(name = " ", limits=new_order$newNames) + labs(colour = "cluster") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

all_mean_sd_sem_network <- data_frame_mean_sd_sem(data_frame = subset_with_clusters_AG_matched, variable = "network_strength", hydra_cluster = 3)

ggplot(all_mean_sd_sem_network, aes(x = cl, y = mean, fill = cl)) +  geom_col() + 
    geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem),width=.2,position=position_dodge(.9)) + 
    xlab("Clusters") + ylab(paste0("Network Strength")) +
    theme(legend.position = "none",
          axis.text.x = element_text(size=30),
          axis.text.y = element_text(size = 20),
          axis.title.y = element_text(size = 30),
          axis.title.x = element_blank(),
          plot.title = element_text(size = 35)) +
    ggtitle(paste0("Network Strength, P=0.043"))  

#violin plot
subset_for_violin <- subset_with_clusters_AG_matched
subset_for_violin$Hydra_k3 <- gsub(pattern = "-1", replacement = "TD", x = subset_for_violin$Hydra_k3)
subset_for_violin$Hydra_k3 <- gsub(pattern = "1", replacement = "Subtype 1", x = subset_for_violin$Hydra_k3)
subset_for_violin$Hydra_k3 <- gsub(pattern = "2", replacement = "Subtype 2", x = subset_for_violin$Hydra_k3)
subset_for_violin$Hydra_k3 <- gsub(pattern = "3", replacement = "Subtype 3", x = subset_for_violin$Hydra_k3)

ggplot(subset_for_violin, aes(x = Hydra_k3, y = network_strength, fill = Hydra_k3)) +  geom_violin() + 
   xlab("Clusters") + ylab(paste0("Network Strength")) +
   scale_y_continuous(limits=c(0, 30)) + 
   theme(legend.position = "none",
          axis.text.x = element_text(size=30),
          axis.text.y = element_text(size = 20),
          axis.title.y = element_text(size = 30),
          axis.title.x = element_blank(),
          plot.title = element_text(size = 35)) +
    ggtitle(paste0("Network Strength, P=0.043"))  

visreg(network_strength_lm)
###################################################
## Extracting anovas with significant p values ####
###################################################

#lm agesq
#Looking at Hydra_k3
#Look at model summaries
models_anova_lm_agesq <- lapply(parcellation_cluster_stats_anova_lm_agesq_AG_matched, summary)

#Pull p-values
p_anova_lm_agesq <- sapply(parcellation_cluster_stats_anova_lm_agesq_AG_matched, function(v) v$"Pr(>F)"[1]) #$coef[,"Pr(>F)"][2]) #get the p value for dep binarized

#Convert to data frame
p_anova_lm_agesq <- as.data.frame(p_anova_lm_agesq)

#print BEFORE FDR correction 
print("LM Agesq anova scores, BEFORE FDR correction: i.e., uncorrected")
print(p_anova_lm_agesq)

#print("LM agesq anova scores, BEFORE FDR correction, p <0.05")
#anova_before_correction_p05 <- as.data.frame(p_anova_lm_agesq[p_anova_lm_agesq <0.05])
#row.names(anova_before_correction_p05) <- row.names(anova_before_correction_p05)[p_round_anova_lm_agesq<0.05]


#Print original p-values to three decimal places
p_round_anova_lm_agesq <- round(p_anova_lm_agesq,3)

#FDR correct p-values
pfdr_anova_lm_agesq <- p.adjust(p_anova_lm_agesq[,1],method="fdr")

#Convert to data frame
pfdr_anova_lm_agesq <- as.data.frame(pfdr_anova_lm_agesq)
row.names(pfdr_anova_lm_agesq) <- parcellations

#To print fdr-corrected p-values to three decimal places
pfdr_round_anova_lm_agesq <- round(pfdr_anova_lm_agesq,3)

#List the components that survive FDR correction
parcellation_fdr_anova_lm_agesq <- row.names(pfdr_anova_lm_agesq)[pfdr_anova_lm_agesq<0.05]

#make a data frame with names and fdr values (rounded to 3 decimals)
parcellation_names_and_fdr_values_anova_lm_agesq <- data.frame(cbind(parcellation_fdr_anova_lm_agesq, round(pfdr_anova_lm_agesq[pfdr_anova_lm_agesq<0.05],3)))

#add titles to names_and_fdr tables
names(parcellation_names_and_fdr_values_anova_lm_agesq) <- c("parcellation", "p_FDR_corr")

print("LM Agesq- Mean centered age that was then squared, FDR corrected")
print(parcellation_names_and_fdr_values_anova_lm_agesq)

######################################################
####Pairwise t-tests for anova-corrected lm means ####
######################################################
#######THIS ONLY WORKS FOR 3 CLUSTERS

#put lm model into emmeans format
parcellation_emmodel_lm_agesq_AG_matched <- lapply(parcellation_cluster_stats_lm_agesq_AG_matched, function(x) {as.list(ref_grid(x))})
parcellation_emmgrid_lm_agesq_AG_matched <- lapply(parcellation_emmodel_lm_agesq_AG_matched, function(x) {as.emmGrid(x)})

#run emmeans
parcellation_emmeans_lm_agesq_AG_matched <- lapply(parcellation_emmgrid_lm_agesq_AG_matched, function(x) {emmeans(x, "Hydra_k3")})

#run pairwise contrasts
parcellation_emmpairs_lm_agesq_AG_matched <- lapply(parcellation_emmeans_lm_agesq_AG_matched, function(x) {pairs(x)})

#Only include stuff that was fdr corrected (i.e., only keep parts of the model (or only display) ones that are corrected),this will be null if nothing was corrected
parcellation_emmpairs_lm_agesq_AG_matched_FDR_corrected <- parcellation_emmpairs_lm_agesq_AG_matched[c(parcellation_fdr_anova_lm_agesq)]


################
  ####Corrected #######
######Make table of contrasts, rows are names of brain regions that are fdr corrected, columns are contrasts, values are pvalues

#contrast names, -1 = controls, 1-3 are clusters
contrast_names <- c("-1 - 1", "-1 - 2", "-1 - 3", "1 - 2", "1 - 3", "2 - 3")

#go through each fdr corrected brain region, and extract p values
contrast_table <- lapply(parcellation_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {round(summary(x)$p.value,3)})

#get the names of the brain regions that were fdr corrected
fdr_corrected_brain_regions <- names(contrast_table)

#build table that will hold the name of the brain region and the p values
pairwise_table <- data.frame(matrix(nrow = length(fdr_corrected_brain_regions), ncol = 6))

#give the appropriate names
rownames(pairwise_table) <- fdr_corrected_brain_regions
colnames(pairwise_table) <- contrast_names

#loop through each brain region, and manually assign the columns to be the p values
for (region in fdr_corrected_brain_regions)
{
  pair_pval <- contrast_table[[region]]
  pairwise_table[region,] <- pair_pval
}

#Add FDR correction
pairwise_table_with_fdr <- pairwise_table
pairwise_table_with_fdr$p_FDR_corr <- parcellation_names_and_fdr_values_anova_lm_agesq$p_FDR_corr


print ("LM Agesq pairwise contrasts and FDR corrrected values Jneurosci parcellations")
print(pairwise_table_with_fdr)

sapply(parcellation_emmpairs_lm_agesq_AG_matched_FDR_corrected, function(x) {print(x)})


#### Plotting only significant FDR stuff ####
if(dim(pairwise_table_with_fdr)[1] > 0 ){
  

parcellations <- row.names(pairwise_table_with_fdr)
cluster_titles <- get_cluster_titles(hydra_cluster = num_clusters)
cluster_vector <- get_cluster_numerical_vector(hydra_cluster = num_clusters)
groups <- data.frame(cbind(cluster_titles, cluster_vector))
names(groups) <- c("cl", "numeric")
total_num_groups <- num_clusters + 1
num_measures <- length(parcellations)

#construct data frame of names of connectivity groups
df_names <- data.frame(rep(groups$cl, num_measures), rep(parcellations, each = total_num_groups))
names(df_names) <- c("cl", "parcellation")

#construct mean_sd_sem data frame
df_mean_sd_sem <- NULL
for(parcellation in parcellations) {
  mean_sd_sem <- data_frame_mean_sd_sem(data_frame = subset_with_clusters_AG_matched, variable = parcellation, hydra_cluster = num_clusters)
  df_mean_sd_sem <- rbind(df_mean_sd_sem, mean_sd_sem)
}

#combine data frames and remove the extra cluster names
all_mean_sd_sem <- data.frame(df_names, df_mean_sd_sem)
all_mean_sd_sem <- subset(all_mean_sd_sem, select = -c(cl.1))
                          
for(parcellation in parcellations){
  for(num in 1:total_num_groups) {
    clst <- groups[num,1]
    meas <- groups[num,2]
    mean_for_eval <- paste("mean(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    mean_grp <- eval(parse(text=as.name(mean_for_eval)))
    all_mean_sd_sem$mean[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- mean_grp
    
    sd_for_eval <- paste("sd(subset_with_clusters_AG_matched$", parcellation, "[which(subset_with_clusters_AG_matched$Hydra_k", num_clusters, " == ", groups[num,2], ")])", sep="")
    sd_grp <- eval(parse(text=as.name(sd_for_eval)))
    all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- sd_grp
    
   
    sem_calc <- paste0("all_mean_sd_sem$sem[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)] <- all_mean_sd_sem$sd[which(all_mean_sd_sem$cl == clst & all_mean_sd_sem$parcellation == parcellation)]/sqrt(length(which(subset_with_clusters_AG_matched$Hydra_k", num_clusters," == meas)))")
    eval(parse(text=as.name(sem_calc)))
  
  }
}

#lets do some parcellation reorganization
parcellations_newNames <- gsub("nback_func_sc_", "", parcellations) #removes the nback_func_sc_
parcellations_newNames <- gsub("_", " ", parcellations_newNames) #converts underscores to spaces
parcellations_newNames <- gsub(" r", " Right", parcellations_newNames) #converts r to Right
parcellations_newNames <- gsub(" l", " Left", parcellations_newNames) #converts l to Left
parcellations_newNames <- gsub("ant", "Anterior", parcellations_newNames) #converts ant to Anterior
parcellations_newNames <- gsub("post", "Posterior", parcellations_newNames) #converts post to Posterior
parcellations_newNames <- gsub("hipp", "hippocampus", parcellations_newNames)
parcellations_newNames <- gsub("rusI", "rus I", parcellations_newNames)
parcellations_newNames <- gsub("fp", "Frontal Pole", parcellations_newNames)
parcellations_newNames <- gsub("mfg", "dorsal frontal", parcellations_newNames)
parcellations_newNames <- gsub("precun", "precuneus", parcellations_newNames)
parcellations_newNames <- gsub("pcc", "posterior cingulate cortex", parcellations_newNames)
#parcellations_newNames <- gsub("pcc", "PCC", parcellations_newNames)
#parcellations_newNames <- gsub("dacc", "dACC", parcellations_newNames)
#parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
#parcellations_newNames <- gsub("vmpfc", "VMPFC", parcellations_newNames)
parcellations_newNames <- gsub("dacc", "anterior cingulate", parcellations_newNames)
parcellations_newNames <- gsub("dlpfc", "DLPFC", parcellations_newNames)
parcellations_newNames <- gsub("vmpfc", "vmPFC", parcellations_newNames)
parcellations_newNames <- gsub("thal", "thalamus", parcellations_newNames)
parcellations_newNames <- gsub(pattern = "\\b([a-z])", replacement = "\\U\\1", parcellations_newNames, perl = TRUE)
parcellations_newNames <- gsub("Vmpfc", "vmPFC", parcellations_newNames)
to_add <- rep(parcellations_newNames, each = num_clusters + 1)
all_mean_sd_sem$newNames <- to_add
#plot
ggplot(data = all_mean_sd_sem, aes(x = newNames, y = mean, group = cl)) + ylab("% Signal Change") +  
  ggtitle("N-back Functional Regions of Interest") + 
  geom_line(aes(color=cl, size=.1), show.legend = F) +
  geom_point(aes(color=cl)) + 
  geom_errorbar(aes(ymin=mean-sem, ymax=mean+sem), width=.1, size=1.5) +
  scale_x_discrete(name = " ") + labs(colour = "cluster") +
  guides(colour = guide_legend(override.aes = list(size=10))) +
  theme(axis.text.x = element_text(size = 20, angle=60, hjust = 1), 
        axis.text.y = element_text(size = 30),
        title = element_text(size = 30), 
        legend.text = element_text(size = 30), 
        plot.title = element_text(size=35),
        legend.title=element_blank())

}



#######Plotting average adj matrices by Subtype ###########
names_of_subtypes <- c("Typically Developing", "Subtype 1", "Subtype 2", "Subtype 3")
node_names <- c("Crus I Right", "Crus II Right", "DLPFC Anterior Left", "Anterior Cingulate", "Medial Frontal Gyrus Left", "Parietal Left", "Precuneus Left", "Precuneus Right")

averages <- readRDS("/Users/eballer/BBL/from_chead/ballerDepHeterogen/results/rds/averages.rds")
td <- averages[[1]]
s1 <- averages[[2]]
s2 <- averages[[3]]
s3 <- averages[[4]]

better_levelplot(adj = td, node_names = node_names, title = "Typically Developing")
better_levelplot(adj = s1, node_names = node_names, title = "Subtype 1")
better_levelplot(adj = s2, node_names = node_names, title = "Subtype 2")
better_levelplot(adj = s3, node_names = node_names, title = "Subtype 3")

mats <- list(td, s1, s2, s3)
lapply(mats, function(mat) {
  better_chorDiagram(adj = mat, node_names = node_names)
})


```

